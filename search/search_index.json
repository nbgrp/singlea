{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Have you ever noticed that existing Single Sign-On solutions do not provide truly single sign-on behavior? Even though the user goes through the full authentication cycle during the very first accessing of protected application, the following very first accessing of another applications which protected by the same SSO leads to recurrence login attempt. Fortunately, it does not need to re-enter the login and password, since the user is already authenticated. But how does it work? And what limitations will you face if your very first request to the application is an XHR?</p> <p>Or maybe you have ever had to migrate a monolithic system to multiple microservices? In that case you may know how complex and cumbersome the user data migration task can be. And how would you feel about the following idea: you can do not migrate user data at all and get it from the request, without overhead and security risks?</p>"},{"location":"#what-is-singlea","title":"What is SingleA","text":"<p>SingleA is a set of Symfony bundles which allows rapid creating of single sign-on service. You would be able to interact with any resources protected by a SingleA instance after the user logs in once. Re-login will be required only after the user logs out or the session expiration.</p> <p>SingleA makes able to expand the initial request with authorization token that can contain user data. Basically, this data is composed of the user attributes, but the Payload Fetcher feature allows receiving additional data to complete the token payload. Depending on the chosen features implementation, the data of payload fetching requests and responses, as well as the token, can be signed and encrypted. The token has a lifetime that allows to cache it and prevent sending redundant requests.</p> <p>SingleA ensures the security of not only transmitted data, but also clients configurations and user data stored on the service side. To do this, all data stored encrypted. Encryption is performed using pairs of rotatable keys and secrets (which known only to the client application or end user).</p>"},{"location":"#further-documentation","title":"Further Documentation","text":"<ul> <li>How It Works is the best way to understand the whole requests cycle between the   client application, the end user and the SingleA instance (server).</li> <li>Features section describes the key design principle which makes SingleA   really flexible and able to solve the most complicated issues.</li> <li>Bundles section contains documentation for each official bundle (included in this project   structure). And the first of them is the main SingleA bundle.</li> <li>SingleAuth is an authentication framework (not quite a protocol) on which SingleA   based (and which gave the name of the project). Read about it to get fully understand abilities of   SingleA.</li> </ul>"},{"location":"#created-by","title":"Created by","text":"<p>The SingleA project was developed by Alexander Menshchikov with gratitude to numerous friends and colleagues who inspired him to this project development.</p> <p>SingleA is among the FOSS projects of nb:group responsible for its further development and support.</p>"},{"location":"how-it-works/","title":"How It Works","text":"<p>The below describes a usage of an official set of SingleA bundles included in the SingleA project. Here described a complete way of user token creation including the secured Payload Feature usage. Step-by-step it will be shown how SingleA works and indicated what and when can be done more simply.</p>"},{"location":"how-it-works/#preparation-of-the-singlea-instance","title":"Preparation of the SingleA Instance","text":""},{"location":"how-it-works/#install-necessary-bundles","title":"Install Necessary Bundles","text":"<p>The SingleA installation consists of 2 parts:</p> <ul> <li>installing the <code>nbgrp/singlea-bundle</code> package which is the core component;</li> <li>and installing required and optional packages (bundles).</li> </ul> <p>SingleA use a modular, contracts based approach. The SingleA bundle demands provision of the <code>nbgrp/singlea-persistence-contracts</code> and <code>nbgrp/singlea-tokenization-contracts</code> implementations. If you do not have your own implementations of these contracts, you can use <code>nbgrp/singlea-redis-bundle</code> and <code>nbgrp/singlea-jwt-bundle</code>. The bundles implement the Payload Fetcher feature are optional.</p> <p>To provide a complete set of SingleA features which may be provided out-of-box with secured implementation of Payload Fetcher, assume the following list of bundles was installed:</p> <ul> <li><code>nbgrp/singlea-bundle</code></li> <li><code>nbgrp/singlea-redis-bundle</code></li> <li><code>nbgrp/singlea-jwt-bundle</code></li> <li><code>nbgrp/singlea-jwt-fetcher-bundle</code></li> </ul> <p>Instead of <code>nbgrp/singlea-jwt-fetcher-bundle</code> you can use <code>nbgrp/singlea-json-fetcher-bundle</code>, but in that case the request and response for additional payload data will contains unprotected JSON object. With usage of <code>singlea-jwt-fetcher-bundle</code> the data transmitting with help of JOSE as signed and (if necessary) in encrypted form.</p>"},{"location":"how-it-works/#configure-bundles","title":"Configure Bundles","text":"<p>A detailed description of each bundle configuration can be found on separate pages in the Bundles section. Here only should be noted that the SingleA bundle includes the settings for:</p> <ul> <li>encryption keys for client features configs and user attributes,</li> <li>restrictions by IP addresses for registration and general requests,</li> <li>a ticket cookie creation,</li> <li>and many others.</li> </ul> <p>The SingleA project was created following the Twelve-Factor App methodology, so environment variables should be used to pass configuration values, if it is possible.</p>"},{"location":"how-it-works/#client-registration","title":"Client Registration","text":"<p>To be able to interact with a previously installed and configured SingleA instance, you need to register your applications. For the description below we will assume that there are 2 client applications with domains app1.domain.org and app2.domain.org. Both of them must be registered by the POST request to the <code>/client/register</code> endpoint (which can be changed if necessary). Assume that both of the applications will use the Request Signature, Tokenization and Payload Fetcher features.</p> <p>The registration requests must contain JSON with the following keys and data.</p> <ul> <li><code>signature</code> (Request Signature) \u2014 the name of the message digest algorithm (which supported by the   PHP OpenSSL extension,   see Signature Algorithms; e.g. \"   SHA256\") and the signature public key in PEM format (which will be used to verify the signature of   the requests to the SingleA server).</li> <li><code>token</code> (Tokenization) \u2014 JWT creation settings, in particular the JWT lifetime, a list of user   claims, JWS and JWE settings (see JWT bundle documentation for more details).</li> <li><code>payload</code> (Payload Fetcher) \u2014 additional payload fetching settings.   Since <code>singlea-jwt-fetcher-bundle</code> is used, it is allowed to use fetch request data signing and   encrypting. Thus, the <code>payload</code> settings are similar to the <code>token</code> settings, but can contain JWS   and JWE settings for both the payload fetch request data and the corresponding response data.</li> </ul> <p>As a response to the registration request, a JSON will be received, which contains the created client id and secret, JWK formatted public keys for validation of the user JWT and JWT from the payload fetch request, and the JWK formatted public key of the recipient of the payload fetch request for whom it must be encrypted.</p>"},{"location":"how-it-works/#registrant-restriction","title":"Registrant Restriction","text":"<p>It is possible to restrict who are able to make registration requests using an <code>allow_if</code> option of a <code>security.access_control</code> rule in a <code>config/packages/security.yaml</code> (the registration request route is <code>/client/register</code> by default). Use the <code>is_valid_registration_ip()</code> and <code>is_valid_registration_ticket()</code> expressions for this. As described in the Symfony documentation page about <code>security.access_control</code>, it is necessary to add one more rule to prevent a request processing according another rule, e.g.:</p> <pre><code>- { path: ^/client/register, allow_if: \"is_valid_registration_ip()\" }\n- { path: ^/client/register, roles: ROLE_NO_ACCESS }\n</code></pre> <p>The second rule may be omitted, if <code>security.access_control</code> rules do not contain other rules which will allow a registration request processing.</p> <p>Trusted IP addresses and subnetworks should be specified in the SingleA bundle settings (<code>singlea.client.trusted_registrars</code>) as CSV formatted string. Similar to the trusted proxies settings it is possible to specify the <code>REMOTE_ADDR</code> value to allow request from any host.</p> <p>To allow registration using a registration ticket, it is necessary to use the <code>is_valid_registration_ticket()</code> expression function and to implement the <code>\\SingleA\\Bundles\\Singlea\\Service\\Client\\RegistrationTicketManagerInterface</code> (an implementation must be able to autowire by an interface name).</p> <p>Tip</p> <p>All these expressions can be used mutually with <code>or</code>/<code>and</code> logical operators. In particular, registration requests can be restricted by the IP address/subnet or by the registration ticket using the expression \"<code>is_valid_registration_ip() or is_valid_registration_ticket()</code>\".</p>"},{"location":"how-it-works/#user-request-processing","title":"User Request Processing","text":"<p>To show a complete way of the user request processing towards a client application using SingleA server, it will be considered the following scenario: at first, not logged-in user interacts with the first client application (app1.domain.org), and then interacts with the second one (app2.domain.org). It will show how the user ticket used by each of them.</p> <p>Client applications can interact with the SingleA server in any available way, but if they work behind a nginx web server, it is the easiest way to use the SingleA Lua client for nginx. It is a lightweight Lua script which need a nginx server compiled with LuaJIT support and a few additional libraries (see link above for more details).</p> <p>The below description will suppose that the client applications are behind the nginx server + the SingleA Lua client, which has the following 4 methods:</p> <ul> <li><code>login()</code> \u2014 check the ticket cookie existence in the user request and validate the user session on   the SingleA server side (if the cookie exists), and redirect the user to login on the SingleA   server if the user has no cookie or the session validation failed;</li> <li><code>logout()</code> \u2014 redirect the user to the SingleA server for logout;</li> <li><code>validate()</code> \u2014 validate the user session on the SingleA server side;</li> <li><code>token(header_name)</code> \u2014 receive the user token from the SingleA server (or from nginx cache, if   exists) and add it into an HTTP header, which name passed in the <code>header_name</code> argument (or   \"Authorization\", if not).</li> </ul> <p>All methods, except <code>logout</code>, return an instance of the SingleA client and can be used in a call chain format. Moreover, there are cases when the client application does not need to receive a user token or to validate a user session (just returning an error when trying to receive a token for unauthorized user). The following description assumes that the <code>login</code> and <code>token</code> methods are chained and a token always is requested for an authorized user.</p>"},{"location":"how-it-works/#request-from-unauthorized-user","title":"Request from Unauthorized User","text":"<p>On the very first request, the user has not yet authenticated on the SingleA server side, therefore a ticket cookie does not exist. During the request processing the SingleA client checks it and redirects the user to the SingleA server for a login. The redirect (login) location contains:</p> <ul> <li><code>client_id</code> and <code>secret</code> \u2014 which were received at registration;</li> <li><code>redirect_uri</code> \u2014 a URI where the user should be redirected to after a successful login;</li> <li><code>signature</code> \u2014 the request signature which prevent the <code>redirect_uri</code>   forgery during the request transmission;</li> <li><code>timestamp</code> \u2014 the request timestamp which is the mandatory signature component that helps to   prevent attacks to the SingleA server by valid requests.</li> </ul> <p>On every request processing the SingleA server verifies the client id and secret, and checks that the client exists.</p> <p>To verify the request signature it is necessary to use the <code>is_valid_signature()</code> expression in an <code>allow_if</code> option of a <code>security.access_control</code> rule (<code>config/packages/security.yaml</code>). Use it for the routes that you want to protect with a signature. Protect all SingleA routes is the best way, for this reason the SingleA Lua client adds signature on every interaction: for login and logout redirect URLs, user session validation requests and user token receive requests.</p> <p>The passed signature check happens by the following algorithm.</p> <ul> <li>Check that the request lifetime has not expired.</li> <li>Make an array with GET parameters which must be used as a signature base.</li> <li>Concatenate values from the array with a <code>.</code> (dot) into a string.</li> <li>Check that the passed in the request signature is valid for the resulting string by   the <code>openssl_verify</code> function (with help of the public key and the message digest algorithm   specified at registration).</li> </ul> <p>See more detailed description of the signature verification algorithm. In particular: how to offset the difference in the SingleA server and the client sides system time, how to exclude unnecessary GET parameters from the signature base array, and why the user login interactive duration has no meaning.</p> <p>Attention</p> <p>If the user is not authenticated, an invalid signature will lead to a redirect to a login page and not to an HTTP error \"Forbidden 403\".</p> <p>The <code>/login</code> route must have the <code>is_fully_authenticated()</code> expression (in addition to the <code>is_valid_signature()</code> expression for a request signature verification) in an <code>allow_if</code> option of a <code>security.access_control</code> rule for a correct behavior.</p> <p>As noted in the case of the registrant restriction, it is important to add an additional rule to prevent an invalid request processing if there is a rule that allows access for anonymous users. Multiple routes may be united in one rule using a regular expression: <pre><code>- { path: ^/(login|validate|token), roles: ROLE_NO_ACCESS }\n</code></pre></p> <p>Between successful signature verification and the user redirect to authentication the initial request URI will be saved into the session for further use.</p> <p>As a result of successful authentication, a set of handlers is called, which:</p> <ul> <li>generate a unique ticket value;</li> <li>make the user attributes set using the <code>\\SingleA\\Bundles\\Singlea\\Event\\UserAttributesEvent</code>, which   will be stored into a firewall (realm) based cache pool tagged by the user identifier;</li> <li>if the SingleA bundle parameter <code>singlea.authentication.sticky_session</code> is set to <code>true</code> and the   user attributes already stored in the cache pool, the lifetime of them will be increased (as a   result of deletion and re-saving the user attributes);</li> <li>the user redirection to the original <code>redirect_uri</code>.</li> </ul> <p>It needs to be explained about increasing the lifetime of the cache item with user attributes and why it is important. The user attributes are storing in the cache pool only during the <code>\\Symfony\\Component\\Security\\Http\\Event\\LoginSuccessEvent</code> handling and are not if the user already has logged in.</p> <p>Other actions process in any way, including if the user already authorized. For this reason, if you use sticky sessions, during an authorization request the user attributes will be saved twice.</p> <p>Important</p> <p>The key of the cache item with user attributes is generated based on the ticket value and the realm \u2014 the name of the firewall that used for the request processing. Read more about realms to understand what it is and when you may need it.</p> <p>If the authenticated user attributes were removed from the cache pool (because expired, were manually removed or by some event listener), the user will be logged out and will be redirected to the <code>redirect_uri</code> (from where should be redirected to the login endpoint again because the ticket cookie was removed as a result of the logout).</p>"},{"location":"how-it-works/#request-from-already-authorized-user","title":"Request from Already Authorized User","text":"<p>Above was described a request processing scenario when the user is not authorized and the request do not contain ticket cookie. But after a successful login the user will receive this cookie and (if the SingleA bundle was configured correctly) it will be available to the SingleA client.</p> <p>If the client application domain (we use app1.domain.org and app2.domain.org) matches the ticket cookie <code>Domain</code> argument (<code>domain.org</code> in our example) the ticket value is available for the SingleA client and the user token (JWT) can be received from the SingleA server via a GET request to the <code>/token</code> route. The ticket value must be specified in the request as an HTTP header \"X-Ticket\" (or any other configured in the SingleA bundle <code>singlea.ticket.header</code> parameter). The user token can be received only for the users whose attributes exist in the cache.</p> <p>In addition to the <code>login()</code> method of the SingleA Lua client, the <code>validate()</code> method can be used to check the user session on the SingleA server side. It needs the ticket cookie to be available.</p> <p>The request to receive the user token will be made only in a case when the token is not contained in a nginx cache (Lua dictionary, more details see below). If the token exists in the cache, it will be taken from there. In any way the token will be appended as an HTTP header <code>Authorization</code> (or other if the custom header name specified in the <code>header_name</code> argument for the <code>token()</code> client method) in the original user request to the client application. In the end the original request passed to the client application for further processing.</p> <p>The JWT generation should be described in more detail, especially because in this example we use the <code>nbgrp/singlea-jwt-fetcher-bundle</code> package for receiving additional payload data.</p> <p>Important</p> <p>The client application can be registered without passing settings for the user token generation (under the <code>token</code> key). If so the token receiving request will lead to an HTTP error \"Forbidden 403\".</p>"},{"location":"how-it-works/#jwt-creation","title":"JWT Creation","text":"<ol> <li>Extract from the user attributes to an array the user claims, which was specified in    the <code>token.claims</code> parameter in the client registration request. This is the basic payload.</li> <li>Make an HTTP request, to receive additional payload data, to the external endpoint specified in    the <code>payload.endpoint</code> parameter at the registration:<ol> <li>build a JWT with payload which contains the user attributes according the user claims    specified in the <code>payload.claims</code> parameter in the client registration request;</li> <li>the JWT is signed with the private key generated for the client during the client    registration, and is encrypted with the public key from the <code>payload.request.jwe.jwk</code>    parameter specified in the client registration request;</li> <li>the request with the JWT as a request body is sending to the external endpoint;</li> <li>the request processing on the endpoint side is out of scope of this description, but it    should be noted that the response must contain a JWT with a payload, which contains data that    should be merged with the basic payload;</li> <li>the response JWT must be signed with the key, which is paired with the specified in    the <code>payload.response.jws.jwk</code> parameter in the client registration request, and must be    encrypted with the public key which was received in the client registration response in    the <code>payload.response.jwe.jwk</code> parameter (if the response JWT encryption is configured for    the client application).</li> </ol> </li> </ol> <p>The JWT can have a lifetime (an <code>exp</code> claim). Since this is configurable by the <code>token.ttl</code> parameter in the client registration request, if it was set, the same value will be duplicated into an HTTP header <code>Cache-Control: max-age</code>. Afterwards, the SingleA client lookup for this header and, if it is found, caches the received token for the specified time. Read more about caching user tokens on the nginx side from the Lua script in the SingleA Lua client description.</p>"},{"location":"how-it-works/#client-restriction-and-signatureticket-validation","title":"Client Restriction and Signature/Ticket Validation","text":"<p>In the same way as in the case of host restriction who is allowed to make registration request, the client requests to the <code>/validate</code> and <code>/token</code> endpoints can be restricted by an IP address or a subnet. To do this it is necessary to configure the <code>singlea.client.trusted_clients</code> parameter of the SingleA bundle with a CSV formatted string with IP addresses/subnets (remember about the <code>REMOTE_ADDR</code> value to allow the request processing from any host). After that you must add the <code>is_valid_client_ip()</code> expression into an <code>allow_if</code> option of a <code>security.access_control</code> rule with a corresponding path.</p> <p>To activate the request signature validation and the ticket validation it is necessary to use the <code>is_valid_signature()</code> and <code>is_valid_ticket()</code> expressions in the same way. Remember about union a few expressions by the <code>and</code> operator:</p> <pre><code>- { path: ^/(validate|token), allow_if: \"is_valid_signature() and is_valid_ticket() and is_valid_client_ip()\" }\n</code></pre> <p>As noted in the case of the registrant restriction, it is important to add an additional rule to prevent an invalid request processing if there is a rule that allows access for anonymous users. Multiple routes may be united in one rule using a regular expression: <pre><code>- { path: ^/(login|validate|token), roles: ROLE_NO_ACCESS }\n</code></pre></p>"},{"location":"how-it-works/#sequence-diagram","title":"Sequence Diagram","text":"<pre><code>%%{init: {\n    \"sequence\": { \"useMaxWidth\": false }\n}}%%\nsequenceDiagram\n    actor User as User / Browser\n    participant App as SingleA client / App\n    participant SingleA as SingleA server\n    participant Payload as Payload Endpoint\n\n    opt App1\n        User-&gt;&gt;+App: Request to app1.domain.org\n        Note over User,App: Request does not&lt;br&gt;contain ticket cookie\n        App-&gt;&gt;App: Check ticket cookie\n        App-&gt;&gt;-User: Redirect user to&lt;br&gt;the SingleA server&lt;br&gt;for authentication\n        Note over User,App: Redirect response contains&lt;br&gt;URI where the user should be&lt;br&gt;redirected after successful login,&lt;br&gt;signature to protect this URI\n\n        User-&gt;&gt;+SingleA: Authentication request with redirect URI,&lt;br&gt;signature, timestamp, client id and secret\n        Note over User,SingleA: Authentication process\n        Note over SingleA: Make user session on the SingleA server side&lt;br&gt;Generate ticket value and store user attributes in a cache&lt;br&gt;Set ticket cookie into response headers\n        SingleA-&gt;&gt;-User: Redirect to redirect URI from authentication request\n\n        User-&gt;&gt;+App: Initial request (app1.domain.org)\n        App-&gt;&gt;App: Check ticket cookie\n        App-&gt;&gt;+SingleA: Validate user session\n        Note over SingleA: Check user attributes existence\n        SingleA--&gt;&gt;-App: OK 200\n        App-&gt;&gt;+SingleA: Get user token\n        Note over SingleA: Compose basic JWT payload\n        SingleA-&gt;&gt;+Payload: Get additional&lt;br&gt;payload data\n        Payload-&gt;&gt;-SingleA: Data\n        Note over SingleA: Merge payload data (with replacement)&lt;br&gt;Add a signature and encrypt the JWT\n        SingleA--&gt;&gt;-App: JWT\n        App-&gt;&gt;App: Add JWT to original request\n        App-&gt;&gt;App: Process request&lt;br&gt;by client application\n        App-&gt;&gt;-User: Response\n    end\n\n    opt App2\n        User-&gt;&gt;+App: Request to app2.domain.org\n        App-&gt;&gt;App: Check ticket cookie\n        App-&gt;&gt;+SingleA: Validate user session\n        Note over SingleA: Check user attributes existence\n        SingleA--&gt;&gt;-App: OK 200\n        App-&gt;&gt;+SingleA: Get user token\n        Note over SingleA: Compose basic JWT payload\n        SingleA-&gt;&gt;+Payload: Get additional&lt;br&gt;payload data\n        Payload-&gt;&gt;-SingleA: Data\n        Note over SingleA: Merge payload data (with replacement)&lt;br&gt;Add a signature and encrypt the JWT\n        SingleA--&gt;&gt;-App: JWT\n        App-&gt;&gt;App: Add JWT to original request\n        App-&gt;&gt;App: Process request&lt;br&gt;by client application\n        App-&gt;&gt;-User: Response\n    end</code></pre>"},{"location":"how-it-works/#read-more","title":"Read More","text":"<ul> <li>About tickets: what is it and what role does it play in SingleA.</li> <li>How to set up and use multiple user providers and authenticators   via realms.</li> <li>About the lifetime configuring.</li> <li>How SingleA Security works (and what is the problem of client registration).</li> <li>About the SingleA client.</li> </ul>"},{"location":"security/","title":"SingleA Security","text":""},{"location":"security/#strengths","title":"Strengths","text":"<p>At the beginning, let's consider the case when we get the strongest protection against attacks to user data (attempts to compromise or forge them) or forge the request to the SingleA server from a user or client. For this assume, that the client was registered with the following features enabled:</p> <ul> <li>Request Signature</li> <li>JWT Tokenizer</li> <li>JWT Payload Feature</li> </ul> <p>To get the required level of protection, the JWT Tokenizer and JWT Payload Fetcher features configurations should include settings for both the signature encryption of data (for the JWT Payload Fetcher feature this applies to both the request and response configuration). Finally, will assume that on the SingleA server side are used rotatable keys for both client feature configs encryption and user attributes encryption.</p> <p>Let's take a closer look at these assumptions.</p>"},{"location":"security/#request-signature","title":"Request Signature","text":"<p>Thanks to the Request Signature feature, you can be sure about 2 things:</p> <ul> <li>GET parameters of the request was not forged during transmission;</li> <li>the time elapsed between sending the request and receiving it by the server does not exceed the   configured limit.</li> </ul> <p>In addition to the Request Signature feature you can use the Symfony Rate Limiter component. See the note about it in the feature description.</p>"},{"location":"security/#jwt-payload-fetcher","title":"JWT Payload Fetcher","text":"<p>Thanks to the signature and encryption of the transmitted data, both from the SingleA server to an external service, which produces an additional user token payload, and vice versa, user data compromise and forgery becomes extremely uneasy. Using reliable algorithms for signing and encrypting data reduces the chance of a successful attack.</p>"},{"location":"security/#jwt-tokenizer","title":"JWT Tokenizer","text":"<p>Similar to the JWT Payload Fetcher, JWT data signing and encrypting helps to avoid user data compromise and forgery, especially when combined with reliable algorithms.</p> <p>Besides, you can use your own implementation of the Tokenization feature that (for example) use a third-party storage, where the SingleA server puts user data, and the client reads it (instead of the direct user data transmission). In this way, an attacker would not be able to extract from the obtained token any useful information.</p>"},{"location":"security/#client-feature-configs-encryption","title":"Client Feature Configs Encryption","text":"<p>Even if an attacker can steal client feature configs from the storage, he will not be able to extract any information from them, since they are persisted in encrypted form. The following components are used to decrypt the configuration.</p> <ul> <li>The client secret provided in every request between the client application (or the user) and the   SingleA server. The secret is known to the client only.</li> <li>Rotatable keys, which should be stored in a safe   place and passed to the SingleA instance dynamically. It is recommended to use SingleA from a   container and provide the keys (as any other configuration) via environment variables.</li> </ul> <p>Do not keep the keys in your SingleA instance code base (e.g. in <code>.env</code> file). Such approach significantly simplifies the task of compromising the feature configs for attackers.</p> <p>Only when both components are present, the contents of the feature configs can be decrypted. And, even if the keys and the secret of one client were stolen, which lead to compromising of this client's feature configs, the configs of other clients are still protected by their secrets.</p> <p>To avoid compromising client secrets, it is recommended not to write GET parameters to the web server logs, or to store them in a safe place.</p>"},{"location":"security/#user-attributes-encryption","title":"User Attributes Encryption","text":"<p>The protection of user attributes is performed in the same way as in the case of client feature configs: they are encrypted using the following 2 components.</p> <ul> <li>The user ticket, which provided via an HTTP header (to prevent it   from been written to the web server logs). The ticket value is extracted by the SingleA client   from cookies of the user request to the client application, which originally set by the SingleA   server when the user was successfully authenticated.</li> <li>Rotatable keys, as in the case of client feature   configs.</li> </ul> <p>If the keys and the ticket of some user were stolen, this does not compromise other users attributes.</p>"},{"location":"security/#weakness","title":"Weakness","text":"<p>There is no typo in the title above. As you may have noticed, if you use all the available SingleA features, you g\u0435t an authentication service and a user token generation service that are totally protected of the Man-in-the-middle (MITM) attacks. And there is only one point in which SingleA cannot guarantee protection for you: client registration.</p> <p>The matter is that even if you are using the HTTPS protocol, when sending a request through an unsafe network (like the Internet) you cannot be absolutely sure that the request will not be intercepted and forged by someone, who owns the root certificates (and encryption keys). It seems like paranoia, but there are countries where it is quite real. The same is true for registration responses.</p> <p>Unfortunately, there is no common solution for this issue. But on the other side the team of the SingleA project proceeds from the fact that the risk of using such heavy methods of attack against the SingleA instance is only possible with respect to serious offenders, who are doing terrible things. Who are doing such things cannot pretend to protection of SingleA. No way.</p> <p>SingleA was made for kind people against the evil.</p> <p>In other cases, to make the registration process safer there are 2 helpful expression language functions, which can be used in an <code>allow_if</code> option of a <code>security.access_control</code> rule: <code>is_valid_registration_ip()</code> and <code>is_valid_registration_ticket()</code>. Read more about them in the Access Control Expression section of the SingleA bundle description.</p> <p>Besides, it is possible to register a new client using the <code>client:register</code> command that takes JSON with client's registration data as an argument. It can be useful in a case, when the registration via an HTTP request cannot be performed for some reason (e.g. for security reasons).</p>"},{"location":"security/#security-advices","title":"Security Advices","text":""},{"location":"security/#https","title":"HTTPS","text":"<p>The use of HTTPS protocol is not mandatory, but it is strongly recommended. The transmission of encrypted data over an unsecured protocol simplifies intercept of data and raises the risk of their compromise.</p> <p>If you have configured the SingleA instance with the <code>singlea.ticket.samesite</code> parameter equals <code>true</code> (see the SingleA bundle configuration for more details), the ticket cookie will forcibly have the <code>Secure</code> attribute and client applications will should work over HTTPS (to be able read the cookie value).</p>"},{"location":"security/#jwe","title":"JWE","text":"<p>This concerns the JWT and JWT Fetcher bundles.</p> <p>If user tokens contain sensitive user data, always use the encryption (see the JWE parameters in the registration parameters in the bundles' description). Do not rely on the HTTPS protocol and a safe communication channel only. Countless user data leaks is a result of the recklessness of those who should have taken care of their protection.</p> <p>Acknowledgements</p> <p>Florent Morselli (also known as Spomky) is a creator of the <code>web-token/jwt-framework</code> package. He has done a great job, thanks to that we can create more reliable applications. Let's take advantage of this opportunity!</p>"},{"location":"security/#strong-algorithms","title":"Strong Algorithms","text":"<p>Use strong algorithms to sign and encrypt data whenever possible.</p> <ul> <li>SHA256/384/512 for Request Signature.</li> <li>ES256/384/512 to sign JWT (JWS parameters).</li> <li>ECDH-ES (and derived) to encrypt JWT keys (JWE parameters).</li> <li>A128GCM/192/256 to encrypt JWT content (JWE parameters).</li> </ul> <p>In the future these recommendations might be changed as more reliable algorithms become available.</p>"},{"location":"security/#keys-rotation","title":"Keys Rotation","text":"<p>Do not ignore an ability to rotate the keys used for encryption of client feature configs and user attributes. Automate this process if possible, but if this is impossible, do it manually periodically. This is significantly increase your SingleA instance reliability.</p>"},{"location":"security/#client-feature-configs","title":"Client Feature Configs","text":"<p>The best solution is to organize a regular re-deploy of the client applications with a certain period (or more often): once a day/week/month or something else. In this case you can rotate the keys for encryption of client feature configs with the chosen period (automatically or manually).</p> <p>If it is not possible to organize a regular re-deploy of the client applications, you can record the generation date for each key and periodically run the <code>client:oldest</code> command, which returns information about the oldest registered client. Among other things, the information contains the client creation date, so the keys older than that date could be removed safely.</p>"},{"location":"security/#user-attributes","title":"User Attributes","text":"<p>If the SingleA configuration parameter <code>singlea.authentication.sticky_session</code> is equals <code>true</code>, you can rotate the keys for encryption of the user attributes periodically. Do this with the period equal to the lifetime of the cache item that keeps the user attributes (read about it in the Cache Pool Management section of the SingleA bundle description). Otherwise, if your user session may last an unexpected period of time, you should think about your own strategy for rotating these keys.</p>"},{"location":"singleauth/","title":"SingleAuth","text":"RFC 2119 <p>The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119.</p> <p>SingleAuth is a lightweight authentication framework which makes able to organize an interaction between an authentication server, client application and end user in such a way that the user only need to log in once, and then the server and client can interact on their own. And even more: any client application using the same authentication server for access protection will be able to interact with the server without any additional user actions: the user request to the client will be enough.</p> <p>Therefore, the SingleAuth based authentication server meets the \"Single Sign-On\" concept from the user's perspective.</p>"},{"location":"singleauth/#features","title":"Features","text":"<p>The SingleAuth based server must implement the following features.</p> <ul> <li>Authentication system: processing login and logout user requests and providing a special   ticket cookie.</li> <li>User session validation by the ticket.</li> <li>User token generation by the ticket (if the user session is valid).</li> </ul> <p>About SingleAuth features</p> <p>Feature is an ability of an authentication server to make done some certain bounded task. In addition to the mandatory features listed above, specific SingleAuth based solution can implement additional features. In particular, SingleA has additional Request Signature and Payload Fetcher features.</p> <p>The SingleAuth framework does not oblige the client to use all the features. Every client decides what features to use, but particular SingleAuth implementation may have its own rules and demands.</p>"},{"location":"singleauth/#client-registration","title":"Client Registration","text":"<p>Every request from the client application or end user to the SingleAuth server must be made with providing a unique client identifier and a secret, which makes it possible to distinguish requests from different clients and process them correctly. For this reason the server must provide the client registration method.</p> <p>The basic registration method should be implemented as an endpoint for POST requests. A valid registration request should contain JSON formatted data. A successful response must contain the client id and secret, and may contain additional data. All this data should be JSON formatted.</p> <p>A particular SingleAuth implementation may restrict client registration according to its business logic.</p>"},{"location":"singleauth/#ticket","title":"Ticket","text":"<p>Ticket is a core of the SingleAuth framework. It is a unique user identifier which allows the SingleAuth client to interact with an authentication server on behalf of the user. The ticket must be provided to the user in a corresponding cookie, which <code>Domain</code> attribute must be matchable with all the client applications using the same SingleAuth server. For example, if you have 2 applications working on app1.domain.org and app2.domain.org, and the SingleAuth instance on sso.domain.org, the ticket cookie must be provided with the <code>Domain=domain.org</code> attribute. This will allow to pass the given ticket in every user request to client applications.</p>"},{"location":"singleauth/#singleauth-flow","title":"SingleAuth Flow","text":"<p>First, the client application must be registered on the SingleAuth server side in any available way. Afterwards, the client id and secret must be included in every request between the SingleAuth server and the client application or end user.</p> <p>When the user doing the very first request to any client application protected by the SingleAuth server, authentication has not yet been performed and the user session does not exist. So the ticket cookie does not exist too and the user must be logged in.</p> <p>If the processing request is an XHR request, it's processing must be immediately finished with an HTTP error Unauthorized 401.</p> <p>After successful authorization the user should be redirected to the initial request URI with preservation of GET parameters. The redirect response must contain the ticket cookie, which will be used further to interact between the SingleAuth client and server without user participation.</p> <p>If the request being processed contains the ticket cookie, the SingleA client validates the user session using an internal request to the SingleA server that includes the ticket value. If the validation was failed, the behavior is the same as if the ticket did not exist.</p> <p>When the validity of the user session is confirmed, the SingleA client can fetch the user token using an internal request to the server (included the ticket value). If the token was successfully received, it is appended to the initial request into the <code>Authorization</code> header, and the request is passed to the client application for further processing. Otherwise, an HTTP error Unauthorized 401 must be returned.</p> <p>Info</p> <p>As noted above, it is not necessary to use all the SingleA server features (the user authentication, user session validation and user token generation). The client application may need only certain features, e.g. the user session validation without fetching the user token, or fetching of the user token without redirecting the user to the login process.</p>"},{"location":"singleauth/#flowchart","title":"Flowchart","text":"<pre><code>%%{init: {\n    \"flowchart\": { \"useMaxWidth\": false }\n}}%%\ngraph TB\n    U([User])\n    R[/Request/]\n    401([Unauthorized 401])\n    App([Client App])\n\n    subgraph client [SingleAuth Client]\n        HT{Does the request&lt;br&gt;have a Ticket?}\n        XHR{XHR?}\n        V[[Validate the user session]]\n        VQ{Is the user session valid?}\n        T[[Fetch the user token]]\n        TR{The token received?}\n        AR[[Add the user token to the request]]\n    end\n\n    subgraph server [SingleAuth Server]\n        L[\\Login/]\n        A{{Authorized}}\n        VS[Validator]\n        TS[Tokenizer]\n    end\n\n    U --&gt;|Makes a request to the Client Application| R\n    R --&gt; HT\n    HT --&gt;|Yes| V\n    HT --&gt;|No| XHR\n    XHR --&gt;|Yes| 401\n    V -.-&gt;|Provide the client id, the secret&lt;br&gt;and the user ticket| VS\n    VS -.-&gt; VQ\n    VQ --&gt;|Yes| T\n    VQ --&gt;|No| XHR\n    T -.-&gt;|Provide the client id, the secret&lt;br&gt;and the user ticket| TS\n    TS -.-&gt; TR\n    TR --&gt;|Yes| AR\n    TR --&gt;|No| 401\n    AR --&gt;|Pass the request to the Client Application| App\n\n    XHR --&gt;|\"No, redirect user to login&lt;br&gt;providing client id, secret&lt;br&gt;and initial request URI&lt;br&gt;as a return URL\"| L\n    L --&gt;|Set ticket cookie| A\n    A --&gt; R\n\n    style client fill:none,stroke:#006cb4,stroke-width:4px,stroke-dasharray: 5 5\n    style server fill:none,stroke:#006cb4,stroke-width:4px\n\n    style U fill:#3ef1e530,stroke:#3ef1e5,stroke-width:3px\n    style 401 fill:#ff888830,stroke:#ff8888,stroke-width:3px\n    style App fill:#55d35a30,stroke:#55d35a,stroke-width:3px</code></pre>"},{"location":"singleauth/#inspired-by","title":"Inspired by","text":"<p>The creation of the SingleAuth framework was inspired by such well-known and reliable protocols as:</p> <ul> <li>OAuth 2.0 and OpenID Connect</li> <li>CAS</li> <li>Kerberos</li> </ul>"},{"location":"bundles/json-fetcher/","title":"JSON Fetcher Bundle","text":""},{"location":"bundles/json-fetcher/#overview","title":"Overview","text":"<p>Implements the <code>nbgrp/singlea-payload-fetcher-contracts</code>.</p> <p>The JSON Fetcher bundle implements receiving an additional user token payload from an external endpoint via an HTTP request containing a JSON with an array composed of user attributes.</p>"},{"location":"bundles/json-fetcher/#installation","title":"Installation","text":""},{"location":"bundles/json-fetcher/#symfony-flex","title":"Symfony Flex","text":"<p>If you use Symfony Flex, you can add an endpoint for access nb:group's recipes, which makes it possible to apply the default bundle configuration automatically when install the bundle:</p> <pre><code>composer config --json extra.symfony.endpoint '[\"https://api.github.com/repos/nbgrp/recipes/contents/index.json\", \"flex://defaults\"]'\n</code></pre> <p>If you wish (or you already have some value of the <code>extra.symfony.endpoint</code> option), you can do the same by updating your <code>composer.json</code> directly:</p> composer.json<pre><code>{\n    \"name\": \"acme/singlea\",\n    \"description\": \"ACME SingleA\",\n    \"extra\": {\n        \"symfony\": {\n            \"endpoint\": [\n                \"https://api.github.com/repos/nbgrp/recipes/contents/index.json\",\n                \"flex://defaults\"\n            ]\n        }\n    }\n}\n</code></pre> <p>Then you can install the bundle using Composer:</p> <pre><code>composer require nbgrp/singlea-json-fetcher-bundle\n</code></pre>"},{"location":"bundles/json-fetcher/#enable-the-bundle","title":"Enable the Bundle","text":"<p>If you use Symfony Flex, it enables the bundle automatically. Otherwise, to enable the bundle add the following code:</p> config/bundles.php<pre><code>return [\n    // ...\n    SingleA\\Bundles\\JsonFetcher\\SingleaJsonFetcherBundle::class =&gt; ['all' =&gt; true],\n];\n</code></pre>"},{"location":"bundles/json-fetcher/#configuration","title":"Configuration","text":"<p>Requests to http (unsecure) endpoints are denied by default. To permit them, you need to add the following bundle configuration:</p> config/packages/singlea_json_fetcher.yaml<pre><code>singlea_json_fetcher:\n    https_only: false\n</code></pre> <p>The bundle uses default Symfony HttpClient. If you need to pass scoped HttpClient, you should override the service <code>SingleA\\Bundles\\JsonFetcher\\JsonFetcher</code> constructor argument:</p> services.yaml<pre><code>services:\n    # ...\n    SingleA\\Bundles\\JsonFetcher\\JsonFetcher:\n        arguments: [ '@custom.client' ]\n</code></pre>"},{"location":"bundles/json-fetcher/#client-registration","title":"Client Registration","text":""},{"location":"bundles/json-fetcher/#request-parameters","title":"Request Parameters","text":"<p>The JSON Fetcher bundle uses <code>payload</code> as the name (key) and <code>json</code> as the hash value to determine own parameters in the client registration data. Besides the hash value, the bundle has the following registration request parameters:</p> <ul> <li><code>endpoint</code> (required) \u2014 a URL to which the POST request should be sent, that contains an array of   user attributes according the <code>claims</code> parameter (it may be an empty array).</li> <li><code>claims</code> (optional) \u2014 an array of the names of user attributes, which should be included in the   request data (if they exist for the user). If a claim ends with <code>[]</code> (square braces), user   attribute named without braces will be included in request data as an array; if the attribute was   not an array, it will be present as a one-element list. If claim does not end with <code>[]</code>, request   data will contain a scalar value; if user attribute is an array, only the first element will be   included.</li> <li><code>options</code> (optional) \u2014 a JSON data structure with additional options which will be passed into the   method <code>Symfony\\Contracts\\HttpClient\\HttpClientInterface::request</code>.</li> </ul> <p>Example:</p> <pre><code>{\n    # ...\n    \"payload\": {\n        \"#\": \"json\",\n        \"endpoint\": \"https://example.domain/_singlea_payload\",\n        \"claims\": [\n            \"email\",\n            \"role[]\"\n        ],\n        \"options\": {\n            \"timeout\": 5\n        }\n    }\n}\n</code></pre>"},{"location":"bundles/json-fetcher/#output","title":"Output","text":"<p>The JSON Fetcher bundle does not add any data to the client registration output.</p>"},{"location":"bundles/jwt-fetcher/","title":"JWT Fetcher Bundle","text":""},{"location":"bundles/jwt-fetcher/#overview","title":"Overview","text":"<p>Implements <code>nbgrp/singlea-payload-fetcher-contracts</code>.</p> <p>The JWT Fetcher bundle implements receiving an additional user token payload from an external endpoint via an HTTP request containing a JWT with a payload composed of user attributes. Due to Spomky's JWT Framework, in addition to a mandatory signature of the JWT, it can be encrypted (according to JOSE).</p>"},{"location":"bundles/jwt-fetcher/#prerequisites","title":"Prerequisites","text":"<p>You need to install the Spomky's JWT Framework (which include JoseFrameworkBundle) before install the SingleA JWT bundle (or simultaneously). This is because the Spomky's bundle, like this one, use dedicated repository for Symfony Flex recipes, and you need to add it in your <code>composer.json</code> or enable the bundle manually.</p>"},{"location":"bundles/jwt-fetcher/#installation","title":"Installation","text":""},{"location":"bundles/jwt-fetcher/#symfony-flex","title":"Symfony Flex","text":"<p>If you use Symfony Flex, you can add an endpoint for access nb:group's recipes, which makes it possible to apply the default bundle configuration automatically when install the bundle:</p> <pre><code>composer config --json extra.symfony.endpoint '[\"https://api.github.com/repos/nbgrp/recipes/contents/index.json\", \"flex://defaults\"]'\n</code></pre> <p>If you wish (or you already have some value of the <code>extra.symfony.endpoint</code> option), you can do the same by updating your <code>composer.json</code> directly:</p> composer.json<pre><code>{\n    \"name\": \"acme/singlea\",\n    \"description\": \"ACME SingleA\",\n    \"extra\": {\n        \"symfony\": {\n            \"endpoint\": [\n                \"https://api.github.com/repos/nbgrp/recipes/contents/index.json\",\n                \"flex://defaults\"\n            ]\n        }\n    }\n}\n</code></pre> <p>Then you can install the bundle using Composer:</p> <pre><code>composer require nbgrp/singlea-jwt-fetcher-bundle\n</code></pre>"},{"location":"bundles/jwt-fetcher/#enable-the-bundle","title":"Enable the Bundle","text":"<p>If you use Symfony Flex, it enables the bundle automatically. Otherwise, to enable the bundle add the following code:</p> config/bundles.php<pre><code>return [\n    // ...\n    SingleA\\Bundles\\JwtFetcher\\SingleaJwtFetcherBundle::class =&gt; ['all' =&gt; true],\n];\n</code></pre>"},{"location":"bundles/jwt-fetcher/#configuration","title":"Configuration","text":"<p>Requests to http (unsecure) endpoints are denied by default. To permit them, you need to add the following bundle configuration:</p> config/packages/singlea_jwt_fetcher.yaml<pre><code>singlea_jwt_fetcher:\n    https_only: false\n</code></pre> <p>The bundle uses default Symfony HttpClient. If you need to pass scoped HttpClient, you should override the service <code>SingleA\\Bundles\\JwtFetcher\\JwtFetcher</code> constructor argument:</p> services.yaml<pre><code>services:\n    # ...\n    SingleA\\Bundles\\JwtFetcher\\JwtFetcher:\n        arguments: [ '@custom.client' ]\n</code></pre>"},{"location":"bundles/jwt-fetcher/#client-registration","title":"Client Registration","text":""},{"location":"bundles/jwt-fetcher/#request-parameters","title":"Request Parameters","text":"<p>The JWT Fetcher bundle uses <code>payload</code> as the name (key) and <code>jwt</code> as the hash value to determine own parameters in the client registration data. Besides the hash value, the bundle has the following registration request parameters:</p> <ul> <li><code>endpoint</code> (required) \u2014 a URL to which the POST request should be sent, that contains an array of   user attributes according the <code>claims</code> parameter (it may be an empty array).</li> <li><code>claims</code> (optional) \u2014 a list of user attribute names to be included in the sending JWT payload (if   they exist for the user). If a claim ends with <code>[]</code> (square braces), user attribute named without   braces will be included in the JWT payload as an array; if the attribute was not an array, it will   be present as a one-element list. If claim does not end with <code>[]</code>, the JWT payload will contain a   scalar value; if user attribute is an array, only the first element will be included.</li> <li><code>request</code> (required) \u2014 a JSON data structure with the following nested objects, which configure   parameters for generating a JWT that will be sent to the endpoint:<ul> <li><code>jws</code> (required) \u2014 JWT signature parameters:<ul> <li><code>alg</code> (required) \u2014 a signature algorithm which should be used for a JWT sending to the   endpoint according RFC 7518   (except \"none\").</li> <li><code>bits</code> (optional) \u2014 a number of bits for generating an OpenSSL private key (applicable for   RSA and octet algorithms).</li> </ul> </li> <li><code>jwe</code> (optional) \u2014 JWT encryption parameters:<ul> <li><code>alg</code> (required) \u2014 a key encryption algorithm according RFC 7518:   4. Cryptographic Algorithms for Key Management.</li> <li><code>enc</code> (required) \u2014 a content encryption algorithm according RFC 7518:   5. Cryptographic Algorithms for Content Encryption.</li> <li><code>zip</code> (optional) \u2014 a JWE compression algorithm according RFC 7518:   7.3. JSON Web Encryption Compression Algorithms Registry.</li> <li><code>jwk</code> (required) \u2014 a JSON data structure which represent a recipient public JWK according   RFC 7518:   6. Cryptographic Algorithms for Keys.</li> </ul> </li> <li><code>options</code> (optional) \u2014 a JSON data structure with additional options which will be passed into   the method <code>Symfony\\Contracts\\HttpClient\\HttpClientInterface::request</code>.</li> </ul> </li> <li><code>response</code> (optional) \u2014 a JSON data structure with the following nested objects which configure   parameters for processing a response JWT:<ul> <li><code>jws</code> (required) \u2014 a JWT signature parameters:<ul> <li><code>alg</code> (required) \u2014 a key encryption algorithm according RFC 7518:   4. Cryptographic Algorithms for Key Management.</li> <li><code>jwk</code> (required) \u2014 a JSON data structure which represent a public JWK for a JWT signature   check according RFC 7518:   6. Cryptographic Algorithms for Keys.</li> </ul> </li> <li><code>jwe</code> (optional) \u2014 a JWT encryption parameters:<ul> <li><code>alg</code> (required) \u2014 a key encryption algorithm according RFC 7518:   4. Cryptographic Algorithms for Key Management   according which will be generated a recipient JWK.</li> <li><code>bits</code> (optional) \u2014 a number of bits for generating an OpenSSL private key (applicable for   RSA and octet algorithms).</li> <li><code>enc</code> (required) \u2014 a content encryption algorithm according RFC 7518:   5. Cryptographic Algorithms for Content Encryption.</li> <li><code>zip</code> (optional) \u2014 a JWE compression algorithm according RFC 7518:   7.3. JSON Web Encryption Compression Algorithms Registry.</li> </ul> </li> </ul> </li> </ul> <p>Tip</p> <p>You can use a helpful CLI tool from Spomky's JWT Framework for JWK generation.</p> <p>Example:</p> <pre><code>{\n    # ...\n    \"payload\": {\n        \"#\": \"jwt\",\n        \"endpoint\": \"https://example.domain/_singlea_payload\",\n        \"claims\": [\n            \"email\",\n            \"role[]\"\n        ],\n        \"request\": {\n            \"jws\": {\n                \"alg\": \"RS256\",\n                \"bits\": 512\n            },\n            \"jwe\": {\n                \"alg\": \"A128KW\",\n                \"enc\": \"A128CBC-HS256\",\n                \"zip\": \"DEF\",\n                \"jwk\": { ... }\n            },\n            \"options\": {\n                \"timeout\": 5\n            }\n        },\n        \"response\": {\n            \"jws\": {\n                \"alg\": \"RS256\",\n                \"jwk\": { ... }\n            },\n            \"jwe\": {\n                \"alg\": \"RSA-OAEP-256\",\n                \"bits\": 1024,\n                \"enc\": \"A256GCM\",\n                \"zip\": \"DEF\"\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"bundles/jwt-fetcher/#output","title":"Output","text":"<p>The JWT Fetcher bundle adds the following data to the client registration output:</p> <ul> <li><code>payload.request.jwk</code> (required) \u2014 the public JWK for the request (sent) JWT signature check.</li> <li><code>payload.response.jwk</code> (optional) \u2014 the recipient public JWK, which the JWT from the response   should be encrypted for (if <code>payload.response.jwe</code> specified in registration data).</li> </ul> <pre><code>{\n    # ...\n    \"payload\": {\n        \"request\": {\n            \"jwk\": { ... }\n        },\n        \"response\": {\n            \"jwk\": { ... }\n        }\n    }\n}\n</code></pre>"},{"location":"bundles/jwt/","title":"JWT Bundle","text":""},{"location":"bundles/jwt/#overview","title":"Overview","text":"<p>Implements <code>nbgrp/singlea-tokenization-contracts</code>.</p> <p>The JWT bundle makes able to generate user token as a JWT. Due to the Spomky's JWT Framework, in addition to mandatory signature, the generated JWT can be also encrypted.</p>"},{"location":"bundles/jwt/#prerequisites","title":"Prerequisites","text":"<p>You need to install the Spomky's JWT Framework (which include JoseFrameworkBundle) before install the SingleA JWT bundle (or simultaneously). This is because the Spomky's bundle, like this one, use dedicated repository for Symfony Flex recipes, and you need to add it in your <code>composer.json</code> or enable the bundle manually.</p>"},{"location":"bundles/jwt/#installation","title":"Installation","text":""},{"location":"bundles/jwt/#symfony-flex","title":"Symfony Flex","text":"<p>If you use Symfony Flex, you can add an endpoint for access nb:group's recipes, which makes it possible to apply the default bundle configuration automatically when install the bundle:</p> <pre><code>composer config --json extra.symfony.endpoint '[\"https://api.github.com/repos/nbgrp/recipes/contents/index.json\", \"flex://defaults\"]'\n</code></pre> <p>If you wish (or you already have some value of the <code>extra.symfony.endpoint</code> option), you can do the same by updating your <code>composer.json</code> directly:</p> composer.json<pre><code>{\n    \"name\": \"acme/singlea\",\n    \"description\": \"ACME SingleA\",\n    \"extra\": {\n        \"symfony\": {\n            \"endpoint\": [\n                \"https://api.github.com/repos/nbgrp/recipes/contents/index.json\",\n                \"flex://defaults\"\n            ]\n        }\n    }\n}\n</code></pre> <p>Then you can install the bundle using Composer:</p> <pre><code>composer require nbgrp/singlea-jwt-bundle\n</code></pre>"},{"location":"bundles/jwt/#enable-the-bundle","title":"Enable the Bundle","text":"<p>If you use Symfony Flex, it enables the bundle automatically. Otherwise, to enable the bundle add the following code:</p> config/bundles.php<pre><code>return [\n    // ...\n    SingleA\\Bundles\\Jwt\\SingleaJwtBundle::class =&gt; ['all' =&gt; true],\n];\n</code></pre>"},{"location":"bundles/jwt/#configuration","title":"Configuration","text":"<p>The bundle configuration includes the following settings:</p> <ul> <li><code>config_default_ttl</code> (default: 600) \u2014 a default JWT lifetime value for new clients who did not   specify the <code>token.ttl</code> registration parameter explicitly.</li> <li><code>issuer</code> (required) \u2014   the <code>iss</code> JWT claim value, unless   another value is explicitly specified in the payload.</li> </ul> config/packages/singlea_jwt.yaml<pre><code>singlea_jwt:\n    config_default_ttl: 1200\n    issuer: 'https://sso.domain.org/'\n</code></pre>"},{"location":"bundles/jwt/#client-registration","title":"Client Registration","text":""},{"location":"bundles/jwt/#request-parameters","title":"Request Parameters","text":"<p>The JWT bundle uses <code>token</code> as the name (key) and <code>jwt</code> as the hash value to determine own parameters in client registration request. Besides the hash value, the bundle has the following registration request parameters:</p> <ul> <li><code>ttl</code> (optional) \u2014 a JWT lifetime in seconds.</li> <li><code>claims</code> (optional) \u2014 a list of user attribute names to be included in the JWT payload (if they   exist for the user). If a claim ends with <code>[]</code> (square braces), user attribute named without   braces will be included in the JWT payload as an array; if the attribute was not an array, it will   be present as a one-element list. If claim does not end with <code>[]</code>, the JWT payload will contain a   scalar value; if user attribute is an array, only the first element will be included.</li> <li><code>jws</code> (required) \u2014 JWT signature parameters:<ul> <li><code>alg</code> (required) \u2014 a signature algorithm which should be used for a JWT sending to the   endpoint according RFC 7518 (except   \"none\").</li> <li><code>bits</code> (optional) \u2014 a number of bits for generating an OpenSSL private key (applicable for   RSA and octet algorithms).</li> </ul> </li> <li><code>jwe</code> (optional) \u2014 JWT encryption parameters:<ul> <li><code>alg</code> (required) \u2014 a key encryption algorithm according RFC 7518:   4. Cryptographic Algorithms for Key Management   .</li> <li><code>enc</code> (required) \u2014 a content encryption algorithm according RFC 7518:   5. Cryptographic Algorithms for Content Encryption   .</li> <li><code>zip</code> (optional) \u2014 a JWE compression algorithm according RFC 7518:   7.3. JSON Web Encryption Compression Algorithms Registry   .</li> <li><code>jwk</code> (required) \u2014 a JSON data structure which represent a recipient public JWK   according RFC 7518:   6. Cryptographic Algorithms for Keys.</li> </ul> </li> </ul> <p>Tip</p> <p>You can use a helpful CLI tool from Spomky's JWT Framework for JWK generation.</p> <pre><code>{\n    # ...\n    \"token\": {\n        \"#\": \"jwt\",\n        \"ttl\": 600,\n        \"claims\": [\n            \"username\",\n            \"email\",\n            \"role[]\"\n        ],\n        \"jws\": {\n            \"alg\": \"RS256\",\n            \"bits\": 512\n        },\n        \"jwe\": {\n            \"alg\": \"RSA-OAEP-256\",\n            \"enc\": \"A256GCM\",\n            \"zip\": \"DEF\",\n            \"jwk\": { ... }\n        }\n    }\n}\n</code></pre>"},{"location":"bundles/jwt/#output","title":"Output","text":"<p>The JWT bundle adds to the client registration output the public JWK, which can be used further to verify the signature of the user's JWT.</p> <pre><code>{\n    # ...\n    \"token\": {\n        \"jwk\": { ... }\n    }\n}\n</code></pre>"},{"location":"bundles/redis/","title":"Redis Bundle","text":""},{"location":"bundles/redis/#overview","title":"Overview","text":"<p>Implements <code>nbgrp/singlea-persistence-contracts</code>.</p> <p>The Redis bundle makes able to store clients metadata and their feature configs in a Redis instance using the SncRedisBundle. The bundle configuration allows declaring certain SingleA features as required to prevent client registration without specify parameters for these features.</p>"},{"location":"bundles/redis/#prerequisites","title":"Prerequisites","text":"<p>This bundle use the SncRedisBundle to operate with a Redis instance. You need to install it yourself and configure a client with alias \"default\" before install the SingleA Redis bundle. The name \"default\" can be changed later.</p>"},{"location":"bundles/redis/#installation","title":"Installation","text":""},{"location":"bundles/redis/#symfony-flex","title":"Symfony Flex","text":"<p>If you use Symfony Flex, you can add an endpoint for access nb:group's recipes, which makes it possible to apply the default bundle configuration automatically when install the bundle:</p> <pre><code>composer config --json extra.symfony.endpoint '[\"https://api.github.com/repos/nbgrp/recipes/contents/index.json\", \"flex://defaults\"]'\n</code></pre> <p>If you wish (or you already have some value of the <code>extra.symfony.endpoint</code> option), you can do the same by updating your <code>composer.json</code> directly:</p> composer.json<pre><code>{\n    \"name\": \"acme/singlea\",\n    \"description\": \"ACME SingleA\",\n    \"extra\": {\n        \"symfony\": {\n            \"endpoint\": [\n                \"https://api.github.com/repos/nbgrp/recipes/contents/index.json\",\n                \"flex://defaults\"\n            ]\n        }\n    }\n}\n</code></pre> <p>Then you can install the bundle using Composer:</p> <pre><code>composer require nbgrp/singlea-redis-bundle\n</code></pre>"},{"location":"bundles/redis/#enable-the-bundle","title":"Enable the Bundle","text":"<p>If you use Symfony Flex, it enables the bundle automatically. Otherwise, to enable the bundle add the following code:</p> config/bundles.php<pre><code>return [\n    // ...\n    SingleA\\Bundles\\Redis\\SingleaRedisBundle::class =&gt; ['all' =&gt; true],\n];\n</code></pre>"},{"location":"bundles/redis/#configuration","title":"Configuration","text":"<p>The bundle configuration includes the following settings:</p> <ul> <li><code>client_last_access_key</code> (default value \"singlea:last-access\") \u2014 the Redis hash table name, which   will be used to store last access timestamps for each client.</li> <li><code>snc_redis_client</code> (default value \"default\") \u2014 the SncRedisBundle client alias name to be used to   access the Redis instance.   See SncRedisBundle documentation   for more details.</li> <li><code>config_managers</code> (required) \u2014 a data structure which defines the configuration for every feature   config manager. The configuration of each feature config manager is presented as a key-value pair   where the key value has no specific meaning, but must be unique; the value should be a data   structure with the following keys:<ul> <li><code>key</code> (required) \u2014 the name of the Redis hash table that the config manager will use to store   appropriate clients configs.</li> <li><code>config_marshaller</code> (required) \u2014 the feature config marshaller service id (see configuration   example below).</li> <li><code>required</code> (boolean, default <code>false</code>) \u2014 defines is this feature mandatory for clients or not   (at registration).</li> </ul> </li> </ul>"},{"location":"bundles/redis/#example","title":"Example","text":"<ol> <li> <p>Configure the SncRedisBundle and define the client alias:   config/packages/snc_redis.yaml<pre><code>snc_redis:\n    clients:\n        default:\n            type: phpredis\n            alias: default\n            dsn: \"%env(REDIS_URL)%\"\n            logging: false\n</code></pre></p> </li> <li> <p>Configure feature config marshallers in the DI container:   config/services.yaml<pre><code>services:\n    # ...\n    singlea.signature_marshaller:\n        class: 'SingleA\\Contracts\\Marshaller\\FeatureConfigMarshallerInterface'\n        factory: '@SingleA\\Bundles\\Singlea\\Service\\Marshaller\\FeatureConfigMarshallerFactory'\n        arguments: [ 'SingleA\\Bundles\\Singlea\\FeatureConfig\\Signature\\SignatureConfigInterface' ]\n\n    singlea.tokenizer_marshaller:\n        class: 'SingleA\\Contracts\\Marshaller\\FeatureConfigMarshallerInterface'\n        factory: '@SingleA\\Bundles\\Singlea\\Service\\Marshaller\\FeatureConfigMarshallerFactory'\n        arguments: [ 'SingleA\\Contracts\\Tokenization\\TokenizerConfigInterface' ]\n\n    singlea.payload_fetcher_marshaller:\n        class: 'SingleA\\Contracts\\Marshaller\\FeatureConfigMarshallerInterface'\n        factory: '@SingleA\\Bundles\\Singlea\\Service\\Marshaller\\FeatureConfigMarshallerFactory'\n        arguments: [ 'SingleA\\Contracts\\PayloadFetcher\\FetcherConfigInterface' ]\n</code></pre></p> </li> <li> <p>Finally, configure the SingleA Redis Bundle:   config/packages/singlea_redis.yaml<pre><code>singlea_redis:\n    client_last_access_key: 'singlea:last-access'\n    snc_redis_client: 'default'\n    config_managers:\n        signature:\n            key: 'singlea:signature'\n            config_marshaller: 'singlea.signature_marshaller'\n            required: true\n\n        tokenizer:\n            key: 'singlea:token'\n            config_marshaller: 'singlea.tokenizer_marshaller'\n            required: true\n\n        payload_fetcher:\n            key: 'singlea:payload'\n            config_marshaller: 'singlea.payload_fetcher_marshaller'\n</code></pre></p> </li> </ol>"},{"location":"bundles/redis/#add-new-feature","title":"Add new feature","text":"<p>To add some custom feature in your SingleA instance, you should:</p> <ul> <li>Create and implement your own feature config interface (which must   extend <code>SingleA\\Contracts\\FeatureConfig\\FeatureConfigInterface</code>), define a new feature config   marshaller in <code>services.yaml</code> with passing created interface FQCN as an argument to the marshaller   factory;</li> <li>Implement <code>SingleA\\Contracts\\FeatureConfig\\FeatureConfigFactoryInterface</code> for processing   registration data and creating client feature config instances.</li> </ul> <p>Read more details about SingleA Features and SingleA Contracts.</p>"},{"location":"bundles/singlea/","title":"SingleA Bundle","text":""},{"location":"bundles/singlea/#overview","title":"Overview","text":"<p>The SingleA bundle is the core bundle in the SingleA project that implements the SingleAuth framework features. Besides, this bundle provides additional opportunities which significantly increase security of the SingleA usage and make it reliable authentication service.</p> <p>The common overview of the SingleA workflow you can find on the How It Works page.</p>"},{"location":"bundles/singlea/#prerequisites","title":"Prerequisites","text":"<p>You need to configure at least one tag aware cache pool with name \"singlea.cache\" to avoid an error at auto-scripts running after the bundle install. You can configure all necessary cache pools at once. See for details on the Cache Pool Management section below.</p>"},{"location":"bundles/singlea/#installation","title":"Installation","text":""},{"location":"bundles/singlea/#symfony-flex","title":"Symfony Flex","text":"<p>If you use Symfony Flex, you can add an endpoint for access nb:group's recipes, which makes it possible to apply the default bundle configuration automatically when install the bundle:</p> <pre><code>composer config --json extra.symfony.endpoint '[\"https://api.github.com/repos/nbgrp/recipes/contents/index.json\", \"flex://defaults\"]'\n</code></pre> <p>If you wish (or you already have some value of the <code>extra.symfony.endpoint</code> option), you can do the same by updating your <code>composer.json</code> directly:</p> composer.json<pre><code>{\n    \"name\": \"acme/singlea\",\n    \"description\": \"ACME SingleA\",\n    \"extra\": {\n        \"symfony\": {\n            \"endpoint\": [\n                \"https://api.github.com/repos/nbgrp/recipes/contents/index.json\",\n                \"flex://defaults\"\n            ]\n        }\n    }\n}\n</code></pre> <p>Then you can install the bundle using Composer:</p> <pre><code>composer require nbgrp/singlea-bundle\n</code></pre> <p>Also, you need to install the Symfony Cache component (or another else the <code>symfony/cache-contracts</code> implementation) that is used to store user attributes (see below).</p>"},{"location":"bundles/singlea/#enable-the-bundle","title":"Enable the Bundle","text":"<p>If you use Symfony Flex, it enables the bundle automatically. Otherwise, to enable the bundle add the following code:</p> config/bundles.php<pre><code>return [\n    // ...\n    SingleA\\Bundles\\Singlea\\SingleaBundle::class =&gt; ['all' =&gt; true],\n];\n</code></pre>"},{"location":"bundles/singlea/#configuration","title":"Configuration","text":"<p>Configuration of the SingleA bundle consists of the following groups of parameters.</p> <ul> <li><code>client</code> \u2014 settings for processing in correct way general SingleA requests and the client   registration requests:<ul> <li><code>id_query_parameter</code> (default: \"client_id\") \u2014 the name of the GET parameter that contains the   client id.</li> <li><code>secret_query_parameter</code> (default: \"secret\") \u2014 the name of the GET parameter that contains the   client secret.</li> <li><code>trusted_clients</code> \u2014 the CSV with the trusted IP addresses / subnets from which general client   request (user session validation and user token generation) allowed (see   details below).</li> <li><code>trusted_registrars</code> \u2014 the CSV with the trusted IP addresses / subnets from which registration   requests allowed (see details below).</li> <li><code>registration_ticket_header</code> (default: \"X-Registration-Ticket\") \u2014 the name of the HTTP header   that can contain the registration ticket value.</li> </ul> </li> <li><code>ticket</code> \u2014 settings related to user tickets:<ul> <li><code>cookie_name</code> (default: \"tkt\") \u2014 the name of the cookie that is set in the response for the   login or logout request and contains the ticket value.</li> <li><code>domain</code> (required) \u2014 the value of the <code>Domain</code> attribute of the ticket cookie. It must be   the common (parent) domain for all the client applications using the same SingleA server and   for the SingleA server itself (e.g. if the client applications have domains <code>app1.domain.org</code>   and <code>app2.domain.org</code>, and the SingleA server has domain <code>sso.domain.org</code>,   the <code>singlea.ticket.domain</code> parameter should be equal to <code>domain.org</code>).</li> <li><code>samesite</code> (default: \"lax\") \u2014 the ticket cookie <code>SameSite</code> attribute value.</li> <li><code>ttl</code> (default: 3600) \u2014 the ticket lifetime in seconds.</li> <li><code>header</code> (default: \"X-Ticket\") \u2014 the name of the HTTP header in the client requests that   contains the ticket value.</li> </ul> </li> <li><code>authentication</code> \u2014 settings related to the authentication functions (login and logout):<ul> <li><code>sticky_session</code> (default: false) \u2014 whether the SingleA user session should   be sticky or not.</li> <li><code>redirect_uri_query_parameter</code> (default: \"redirect_uri\") \u2014 the name of the GET parameter,   which contains the URI to which the user should be redirected after a successful login or   logout.</li> </ul> </li> <li><code>signature</code> \u2014 settings related to the Request Signature feature:<ul> <li><code>request_ttl</code> (default: 60) \u2014 the client request timeout in seconds: maximum amount of time   that can elapse between the client request initiation and this request processing by the   SingleA server.</li> <li><code>signature_query_parameter</code> (default: \"sg\") \u2014 the name of the GET parameter that contains the   value of the request signature.</li> <li><code>timestamp_query_parameter</code> (default: \"ts\") \u2014 the name of the GET parameter that contains the   value of the request initiation timestamp.</li> <li><code>extra_exclude_query_parameters</code> \u2014 a list of GET parameter names to be excluded from request   signature validation (e.g. some technical or marketing parameters).</li> </ul> </li> <li><code>encryption</code> \u2014 settings for client feature configs   and user attributes encryption:<ul> <li><code>client_keys</code> (required) \u2014 a list of the sodium 256-bit keys that using to encrypt/decrypt   client feature configs (read   about client feature configs encryption below).</li> <li><code>user_keys</code> (required) \u2014 a list of the sodium 256-bit keys that using to encrypt/decrypt   user attributes (read about user attributes encryption below).</li> </ul> </li> <li><code>realm</code> \u2014 settings of the Realms:<ul> <li><code>default</code> (default: \"main\") \u2014 the realm to use if the current request does not contain the GET   parameter with an explicit realm value.</li> <li><code>query_parameter</code> (default: \"realm\") \u2014 the name of the GET parameter that can contain the   necessary realm name.</li> </ul> </li> <li><code>marshaller</code> and <code>user_attributes</code> \u2014 groups consisting of the only <code>use_igbinary</code> parameter which   setting to use or not the igbinary extension   for serialization of client feature configs and user attributes. By default, if the igbinary   extension is available and the extension version is greater than 3.2.2, the igbinary functions   will be used for serialization.</li> </ul>"},{"location":"bundles/singlea/#routes","title":"Routes","text":"<p>Update your routes configuration:</p> config/routes.yaml<pre><code>singlea:\n    resource: '@SingleaBundle/Resources/config/routes.php'\n</code></pre>"},{"location":"bundles/singlea/#trusted-ip-addresses-subnets","title":"Trusted IP addresses / subnets","text":"<p>The values of the <code>singlea.client.trusted_clients</code> and <code>singlea.client.trusted_registrars</code> parameters can contain comma-separated list of IP addresses or subnets from which appropriate requests are allowed. Also, it is possible to use the <code>REMOTE_ADDR</code> value to allow request from any host. This approach was inspired by Symfony's <code>framework.trusted_proxies</code> parameter (see an article How to Configure Symfony to Work behind a Load Balancer or a Reverse Proxy from Symfony documentation).</p>"},{"location":"bundles/singlea/#sodium-encryption-keys","title":"Sodium encryption keys","text":"<p>It is possible to use together the Symfony build-in environment variable processor <code>csv</code> and SingleA custom processor <code>base64-array</code> to pass the CSV-encoded list of base64-encoded sodium keys (generated by the <code>sodium_crypto_secretbox_keygen()</code> function) to the <code>singlea.encryption.*</code> parameters:</p> config/packages/singlea.yaml<pre><code>singlea:\n    # ...\n    encryption:\n        client_keys: '%env(base64-array:csv:CLIENT_KEYS)%'\n        user_keys: '%env(base64-array:csv:USER_KEYS)%'\n</code></pre>"},{"location":"bundles/singlea/#client-registration","title":"Client Registration","text":""},{"location":"bundles/singlea/#request-parameters","title":"Request Parameters","text":"<p>The SingleA bundle uses <code>signature</code> as the name (key) of an object with configuration of the Request Signature feature in the client registration request, which includes the following parameters:</p> <ul> <li><code>md-alg</code> (required) \u2014 the name of   the signature algorithm to be used to   sign requests. The value should contain the available constant name without   the <code>OPENSSL_ALGO_</code> prefix (e.g. \"SHA256\").</li> <li><code>key</code> (required) \u2014 the public key in PEM format to be used to verify the signature of the request   being processed.</li> <li><code>skew</code> (optional) \u2014 the difference between the server and the client system time in seconds (the   server time minus the client time).</li> </ul> <p>Example:</p> <pre><code>{\n    # ...\n    \"signature\": {\n        \"md-alg\": \"SHA256\",\n        \"key\": \"MI...\",\n        \"skew\": 7200\n    }\n}\n</code></pre>"},{"location":"bundles/singlea/#output","title":"Output","text":"<p>The SingleA bundle adds the generated client id and secret to the client registration output.</p> <pre><code>{\n    # ...\n    \"client\": {\n        \"id\": \"...\",\n        \"secret\": \"...\"\n    }\n}\n</code></pre>"},{"location":"bundles/singlea/#details","title":"Details","text":"<p>Let's take a closer look at some of SingleA's capabilities.</p>"},{"location":"bundles/singlea/#user-tokens","title":"User Tokens","text":"<p>When you are building multiple applications with the same authentication point, often the question of access to user data significantly increase the complexity of development and even becomes a headache. The special case of such applications are microservices.</p> <p>The more applications there are, the more relevant become the following questions:</p> <ul> <li>How to pass into the application the only necessary user data (and do not pass redundant data)?</li> <li>How to transmit them safely?</li> <li>How to add a new application with the minimal cost of time and without involving additional   specialists?</li> <li>How to achieve all this without performance penalty as increase the number of applications?</li> </ul> <p>SingleA offers User Tokens as an answer for all of these questions. The user token is a unique string that allows to get user data on the client application side. Meanwhile, a different token is generated for each application and each of them provides only the data necessary for this application. The simplest and commonly used way is to use JWT (JSON Web Token), which allows passing user data encoded directly in the token. This type of user tokens will be described below.</p> <p>Besides, you can create your own implementation of the Tokenization Feature, which will generate tokens by your logic. For example, as a token you can use a unique key that allows a client application to get user data from some shared storage where the SingelA server puts the data during the token generation request.</p> <p>The SingleA project includes the JWT bundle (package <code>nbgrp/singlea-jwt</code>) for generating user tokens in the JWT format. It allows transmitting user data as a part of the JWT payload using of mandatory signature (RFC 7515: \"JSON Web Signature (JWS)\") to prevent data forgery and optional encryption (RFC 7516: \"JSON Web Encryption (JWE)\") to prevent sensitive data leaks.</p> <p>The token can have a lifetime that allows proxy servers and the client application to cache it. This leads to reduce the SingleA server load and solve the performance problem. It is especially actual when the Payload Fetcher feature is used (see below).</p> <p>When registering a client, the <code>token</code> parameters set can contain a user claims list \u2014 names of user attributes which must be included in the token payload (see Client Registration &gt; Request Parameters for more details about the <code>token</code> parameters). But there are cases when this data is not enough, and it is necessary to add some extra data that is known only to an external service (e.g. data based on some business-specific logic). In this case it is possible to use the Payload Fetcher feature, which allows the SingleA server to send an additional HTTP request to an external service with transmitting there a set of user attributes and getting as a response additional data that should be merged into a final token payload.</p> <p>The SingleA project contains 2 implementations of the Payload Fetcher feature:</p> <ul> <li>JSON Fetcher \u2014 getting user data via simple POST request with transmitting data   without any protection (as clear text). It is acceptable when you are absolutely sure of the   security of the communication channel between the SingleA server and the service to which the   request will be sent.</li> <li>JWT Fetcher \u2014 data transmitting as a part of a JWT payload with using mandatory   signature (JWS) and optional encryption (both of request and response data).</li> </ul>"},{"location":"bundles/singlea/#user-attributes","title":"User Attributes","text":"<p>The user properties that is using to compose user token payload or a data set which is sending to an external service to retrieve an extra payload data, are named User Attributes in SingleA terms. It is a key-value structure, where the \"key\" is a user claim and the \"value\" is a scalar or an array that is fetched or calculated at the <code>SingleA\\Bundles\\Singlea\\Event\\UserAttributesEvent</code> handling, which is raised at the <code>Symfony\\Component\\Security\\Http\\Event\\LoginSuccessEvent</code> handling.</p> <p>User attributes are stored as a tagged Symfony Cache items. This is due to the following reasons.</p> <ol> <li>SingleA is not intend persistence of any user data, only temporary caching for the user session    lifetime. The data must be \"forgotten\" by the SingleA server after the cache item expired or if    the user was logged out. For this reason the user session lifetime is equal to the cache item    lifetime that controlled by the Symfony Cache settings    (see below about the cache pool management).</li> <li>The Symfony Cache component provides a convenient way to encrypt cache data and a reach set of    supported    cache adapters.</li> <li>With help of cache tags, it is possible to forcibly log the user out using the    command <code>user:logout &lt;identifier&gt;</code>.</li> </ol> <p>Redis and tags</p> <p>Keep in mind that the rows for outdated cache items in tags hash sets will not be removed by the command <code>cache:pool:prune</code>. You need to erase them by yourself.</p> <p>Besides, you need to allocate enough memory for cache items (read about memory allocation and key eviction in the Redis documentation).</p> <p>User data is stored in the cache in encrypted form. The user attributes values encrypting using the <code>sodium_crypto_secretbox()</code> function, which takes as arguments the first key from the parameter <code>singlea.encryption.user_keys</code> and user ticket (which will be considered in detail below). Unlike a use of the service <code>Symfony\\Component\\Cache\\Marshaller\\SodiumMarshaller</code> for Encrypting the Cache, this way allows encrypting user data simultaneously with a rotatable sodium keys and a personal \"secret\" that known the only user.</p> <p>The remaining keys from the parameter are used to decrypt previously stored values. Read about these keys above.</p>"},{"location":"bundles/singlea/#cache-pool-management","title":"Cache pool management","text":"<p>As it was written above, the user session lifetime is equal to the lifetime of the cache item that keeps user attributes. But which cache pool is used to store this cache item?</p> <p>SingleA uses a separate pool for user attributes for each Realm (what is the Realm will be considered below). You can configure each pool explicitly: use the pattern <code>singlea.cache.[realm]</code> to name cache pools.</p> <p>The cache pool for each realm that was not configured explicitly will be created based on the special cache pool named <code>singlea.cache</code> that should be configured in this case (when there is any realm without an explicitly configured cache pool).</p> <p>It is necessary to use tag aware cache adapters for cache pools that will be used to store user attributes, because tags is used to tag cache items with the user's identifier and make able to forcibly log the user out by the command <code>user:logout &lt;identifier&gt;</code>.</p> <p>The cache item lifetime (which was written about a little above) is configured by the <code>default_lifetime</code> cache pool parameter.</p> <p>User attributes are common for each client application so there is no meaning to set cache item lifetime in any other way, e.g. using the <code>Psr\\Cache\\CacheItemInterface::expiresAt</code> method.</p>"},{"location":"bundles/singlea/#ticket","title":"Ticket","text":"<p>The Ticket is a unique string that is generated at the user successful authentication (at the <code>Symfony\\Component\\Security\\Http\\Event\\LoginSuccessEvent</code> handling). The ticket resembles a user session identifier: it is a 192-bit random string that is used as an argument <code>nonce</code> in the <code>sodium_crypto_secretbox()</code> and <code>sodium_crypto_secretbox_open()</code> functions. Also, in a pair with the current realm (the firewall name as it described below) the ticket acts as a key for access to the cache item that keeps attributes of the user.</p> <p>The ticket value is transmitted to the user as a cookie and must be accessible for a client application (or a SingleA client). To achieve this goal, the <code>Domain</code> cookie attribute should be set to a domain that is common for all client applications and the SingleA server. For example, if applications work with domains <code>app1.domain.org</code> and <code>app2.domain.org</code>, and the SingleA server works with a domain <code>sso.domain.org</code>, the ticket cookie <code>Domain</code> attribute should be equal to <code>domain.org</code>.</p> <p>Besides, if the client application handle \"non-same-origin\" requests, it is necessary to set a <code>none</code> as a value of the <code>singlea.ticket.samesite</code> parameter.</p> <p>!!! caution: \"\"</p> <pre><code>In this case all the client applications and the SingleA instance should work over the HTTPS\nprotocol, because the ticket cookie must have the `Secure` attribute.\n</code></pre> <p>Only the user knows the ticket value (it does not store on the SingleA side), so there is no point in stealing data from the cache storage. But even if some user's attributes were compromised, it does not make able to compromise any other user attributes. Coupled with rotatable encryption keys on the SingleA server side (which the best way to keep in an isolated secrets storage), tickets provide a reliable protection of user data.</p>"},{"location":"bundles/singlea/#lifetimes-user-attributes-tickets-tokens","title":"Lifetimes: User Attributes, Tickets, Tokens","text":"<p><code>User Attributes TTL &gt; Ticket TTL &gt; Token TTL</code></p> <p>The expression above reflects the next idea: configure the ticket lifetime less than the user attributes lifetime and greater than the token lifetime. When the token expires, the ticket acts as a refresh token and makes able to request new token. When the ticket expires, the user will be redirected to a logging in and, if a Symfony (PHP) session is still alive and the user attributes were not expired, the ticket will be regenerated and the user will be redirected back without any interactive login process.</p> <p>Even if the PHP session was expired, it does not matter for intercommunication between the client application (or the SingleA client) and the SingleA server, because only the cache item with user attributes is necessary for client request processing.</p>"},{"location":"bundles/singlea/#realms","title":"Realms","text":"<p>The Realm is an authentication point on the SingleA server side. Actually it is a Symfony firewall. The user or client request can include a GET parameter that determines which realm (firewall) should be used for the request processing. This makes it possible to choose the necessary user provider. Thanks to the session fixation strategy <code>SessionAuthenticationStrategy::MIGRATE</code> (see the Symfony documentation about the <code>security.session_fixation_strategy</code> parameter) it is possible to be authenticated via multiple firewalls at the same time. Since user attributes store in a cache item which key based on the realm and ticket values, the user attributes received from different user providers are independent and can contain different values.</p> <p>To select the appropriate realm, the best way to use the <code>request_matcher</code> firewall field in the security settings and the special <code>SingleA\\Bundles\\Singlea\\Request\\RealmRequestMatcher</code> service in the following way:</p> config/packages/security.yaml<pre><code>security:\n    # ...\n    firewalls:\n        main:\n            # Use the service FQCN and the firewall name separated by a dot\n            request_matcher: SingleA\\Bundles\\Singlea\\Request\\RealmRequestMatcher.main\n</code></pre> <p>If you prefer native PHP configuration format, you can do the same in the following way:</p> config/packages/security.php<pre><code>&lt;?php\n\nuse SingleA\\Bundles\\Singlea\\Request\\RealmRequestMatcher;\nuse Symfony\\Config\\SecurityConfig;\n\nreturn static function (SecurityConfig $config): void {\n    // ...\n    $mainFirewall = $config-&gt;firewall('main');\n    $mainFirewall-&gt;requestMatcher(RealmRequestMatcher::for('main'));\n}\n</code></pre> <p>Example</p> <p>Thanks to the realms it is possible to organize an access to your corporate application for users from an external Identity Provider service (e.g. Active Directory of your business partner) without the need to create accounts for them in your corporate Identity Provider service or setup their proxying.</p>"},{"location":"bundles/singlea/#sticky-sessions","title":"Sticky Sessions","text":"<p>As mentioned above, the user session lifetime is equal to the lifetime of the cache item that keeps user attributes. When this cache item expires, the user will be forced to log in again (because this is the only way to compose user attributes). Even if the PHP session was not expired, it will be invalidated and the user will be logged out forcibly.</p> <p>But since the default behavior in the Symfony framework assumes to prolong the session lifetime when you interact with it, there is the <code>singlea.authentication.sticky_session</code> parameter (default: <code>false</code>) that makes it possible to prolong the lifetime of the cache item that keeps user attributes when the user logging in (even if the user already was authenticated).</p> <p>General request to the SingleA server do not prolong the lifetime of the cache item with user attributes in contrast with the PHP session lifetime, which is increased using the Symfony framework.</p> <p>Using of Sticky Sessions may lead to the case when user attributes is not updated for a long time because they are reloaded at the successful user login (at the <code>Symfony\\Component\\Security\\Http\\Event\\LoginSuccessEvent</code> handling).</p> <p>Regardless of the use of Sticky Sessions, after the ticket cookie expires the user will be redirected to log in.</p>"},{"location":"bundles/singlea/#events","title":"Events","text":"<p>There are several events that can be used to customize the behavior of the SingleA server.</p>"},{"location":"bundles/singlea/#loginevent","title":"LoginEvent","text":"<p>FCQN: <code>SingleA\\Bundles\\Singlea\\Event\\LoginEvent</code></p> <p>This event is instantiated in the <code>Login</code> controller (<code>/login</code>) and used for a Response creation and any additional actions. In particular, the build-in <code>LoginEvent</code> listener adds a ticket cookie in the Response and prolongs the cache item that keeps user attributes (if the Sticky Sessions is used).</p>"},{"location":"bundles/singlea/#userattributesevent","title":"UserAttributesEvent","text":"<p>FCQN: <code>SingleA\\Bundles\\Singlea\\Event\\UserAttributesEvent</code></p> <p>As mentioned above, this event is instantiated when the user logged in successfully and is used to compose user attributes. You need to create your own <code>UserAttributesEvent</code> listener or subscriber, otherwise user attributes will be empty.</p> <p>This is applicable if you are not going to use the SingleA instance for a user tokens generation (only for authentication and user session validation), or if you are going to fetch the whole token payload from an external service using the Payload Fetcher without passing user attributes.</p> <p>You can use the <code>SingleA\\Bundles\\Singlea\\Service\\Realm\\RealmResolver</code> service to determine the current realm (firewall name).</p>"},{"location":"bundles/singlea/#payloadcomposeevent","title":"PayloadComposeEvent","text":"<p>FCQN: <code>SingleA\\Bundles\\Singlea\\Event\\PayloadComposeEvent</code></p> <p>This event allows you to modify basic user token payload (before a fetch additional payload from an external service, if it is used by the client). In some cases this approach can replace the Payload Fetcher use.</p>"},{"location":"bundles/singlea/#customization","title":"Customization","text":"<p>The most SingleA classes declared as <code>final</code>, so they cannot be extended explicitly.</p> <p>SingleA customization is able in two ways.</p> <ul> <li>By using a   service decoration.</li> <li>You can implement the necessary service interface and override it in   the service container   configuration (<code>config/services.yaml</code>).</li> </ul>"},{"location":"bundles/singlea/#security","title":"Security","text":"<p>SingleA security is given special attention, because often due to security issues attackers gain access to user data. You can read more about the used security methods on the SingleA Security section (and also about the \"Achilles heel\" of SingleA and what you should protect yourself).</p> <p>SingleA protective equipment can be divided into 2 groups: mandatory, which managed by the SingleA configuration, and optional, the use of which is up to you. Let's take a closer look at them below.</p>"},{"location":"bundles/singlea/#access-control-expression","title":"Access Control Expression","text":"<p>SingleA includes a security Expression Language Provider that adds the following functions. They can be used in an <code>allow_if</code> option (read more about Securing by an Expression) of a <code>security.access_control</code> rule.</p> <ul> <li><code>is_valid_signature()</code> \u2014 check whether the current request has a valid signature.   The Request Signature feature should be enabled for a client,   otherwise the check will not be performed and validation will be considered passed.</li> <li><code>is_valid_ticket()</code> \u2014 check whether the current request has an HTTP header with a valid ticket.</li> </ul> <p>Here the ticket validity do not consider an existence of user attributes that relate to the ticket. The ticket consider as valid if it exists and has a valid format.</p> <ul> <li><code>is_valid_client_ip()</code> \u2014 check whether the current request IP address is allowed according to the   parameter <code>singlea.client.trusted_clients</code> (see details above).</li> <li><code>is_valid_registration_ip()</code> \u2014 check whether the current request IP address is allowed according   to the parameter <code>singlea.client.trusted_registrars</code> (see   details above).</li> <li><code>is_valid_registration_ticket()</code> \u2014 check whether the current request has an HTTP header with a   valid registration ticket.</li> </ul>"},{"location":"bundles/singlea/#registration-ticket","title":"Registration Ticket","text":"<p>In addition to the ability to restrict access to the registration route (controller) by the request sender IP address (or subnet), SingleA make it possible to use Registration Tickets \u2014 strings that should be passed via an HTTP header and verified by the service that implements the <code>SingleA\\Bundles\\Singlea\\Service\\Client\\RegistrationTicketManagerInterface</code>.</p> <p>The <code>is_valid_registration_ticket()</code> expression language function, as any other, can be used together with other functions using logical operations <code>or</code>/<code>and</code>. For example, to restrict a registration request by an IP address/subnet or registration ticket, you can use the following expression:</p> <pre><code>is_valid_registration_ip() or is_valid_registration_ticket()\n</code></pre>"},{"location":"bundles/singlea/#encryption","title":"Encryption","text":"<p>As described above, SingleA stores client feature configs and user attributes in encrypted form. In both cases, sets of rotatable keys are used together with secrets (client secret and user ticket) that are known for the client or user only.</p>"},{"location":"bundles/singlea/#client-feature-configs-encryption","title":"Client Feature Configs Encryption","text":"<p>For client feature configs encryption used keys, which is generated by the <code>sodium_crypto_secretbox_keygen()</code> function and a client secret (that is known for the client only). The keys are more convenient to keep as a comma-separated base64-encoded list in an environment variable that can be passed in the parameter <code>singlea.encryption.client_keys</code> using the <code>%env(base64-array:csv:CLIENT_KEYS)%</code> expression (if the environment variable called <code>CLIENT_KEYS</code>).</p> <p>The first key from the list always used for encryption. The remaining keys (with the first too) are used in turn when decrypting the stored value. Therefore, a new key should always be added at the beginning of the list.</p>"},{"location":"bundles/singlea/#user-attributes-encryption","title":"User Attributes Encryption","text":"<p>The principle of user attributes encryption is the same as described above for client feature configs, with only difference that the keys present in the <code>singlea.encryption.user_keys</code> parameter and as a secret is used user ticket (which is transmitted via a cookie and is known for the user only). Then the ticket must be passed to the SingleA server via an HTTP header of a client request.</p> <p>The Symfony Cache component allows you to use the service <code>Symfony\\Component\\Cache\\Marshaller\\SodiumMarshaller</code> for cache items encryption. This approach cannot replace SingleA requirement for user attributes encryption, but it will be useful if you are going to store in the cache some other sensitive data except user attributes.</p>"},{"location":"client/concept/","title":"SingleA Client Concept","text":"<p>SingleA solves the following 3 issues:</p> <ul> <li>authenticate the user;</li> <li>validate user session;</li> <li>generate user token.</li> </ul> <p>The easiest way to integrate your client application with the SingleA server and use all these abilities is to use the SingleA client. It allows you to do not spend your time on finding out with details of the SingleAuth framework and the SingleA server implementation.</p> <p>The SingleA client should be able to solve the following use cases:</p> <ul> <li>deny access (whole or partly) to the client application for unauthenticated users and redirect   them to the SingleA server for authentication, if necessary, with subsequent redirect them back to   the application;</li> <li>receive from the SingleA server user token and append it to the   original request (for a further processing on the application side);</li> </ul> <p>The correct configuration of the SingleA client should allow you to do not worry about an integration with the SingleA server and be sure that, if the request contains user token, so the user is authenticated, and you can get user data from the token or using it.</p> <p>It is worth to be noted that user authentication is not mandatory for using the client application. The SingleA client should provide an ability to use it for anonymous users if you want it.</p> <p>The ability to fine tune the SingleA client, which takes into account all the SingleA server capabilities, is an important part of the client implementation. At present there are the following implementations of the SingleA client:</p> <ul> <li>nginx Lua client</li> </ul> <p>This list will expand in the future.</p>"},{"location":"client/nginx/","title":"Nginx Lua Client","text":""},{"location":"client/nginx/#overview","title":"Overview","text":"<p>One of the most popular reverse proxy servers today is nginx. You can explore a numerous benefits, which nginx provides, in the official documentation and in many articles about this topic. The most frameworks have an examples of a nginx configuration for running web application based on these frameworks. For example, you can see such an example in the Symfony documentation.</p> <p>Nginx has a lot of useful modules, one of them is the lua-nginx-module, which makes able to run Lua scripts directly from nginx site configuration using the LuaJIT compiler. This module allows you to perform the necessary checks before pass the request for further processing, modify the original request or redirect the user to another URL. The SingleA Lua client for nginx, which is described below, is based on this approach.</p>"},{"location":"client/nginx/#installation","title":"Installation","text":"<p>First you need install nginx compiled with lua-nginx-module and LuaJIT 2.1 (or later). Besides, you need to install the following Lua packages that the SingleA Lua client depends on:</p> <ul> <li>http</li> <li>lua-resty-http</li> <li>base64</li> </ul> <p>and dependent packages for them. It is recommended to use the LuaRocks to install this packages.</p> <p>When nginx, LuaJIT and all necessary Lua packages are installed, you need to create a directory for Lua scripts, which will contain our SingleA client (e.g. <code>/etc/nginx/lua</code>) and copy there the file <code>singlea-client.lua</code> from the client repository <code>nbgrp/singlea-nginx-lua</code>. In the main nginx configuration file (<code>/etc/nginx/nginx.conf</code>), you need to add the following directives in the <code>http</code> section (use your path to the directory with Lua scripts):</p> <pre><code>lua_package_path '/etc/nginx/lua/?.lua;;';\nlua_shared_dict tokens 1m;\n</code></pre> <p>The <code>lua_shared_dict</code> directive defines the dictionary (the key-value storage that shared between all nginx workers), which will be used to cache user tokens that received from the SingleA server. It will be described in more details below, here it is only should be noted that the dictionary name <code>tokens</code> can be any other else, and you can allocate different amount of memory for the dictionary (not only 1 megabyte as in the example above).</p>"},{"location":"client/nginx/#configuration","title":"Configuration","text":"<p>There are 2 ways to configure the SingleA Lua client: by explicit specifying of parameters when initialize the client, and by environment variables. The second one is especially useful when you deploy the client application using containers and follow the 12-Factor App principles. See an example of explicit configuration below.</p> <p>To access environment variables from the Lua script in the nginx configuration context, you should use the <code>env</code> directive. It makes it possible to use system-wide defined environment variables or define your own, which will be used only by nginx workers.</p> <p>Each explicit parameter of the client constructor has a paired environment variable, which has an uppercase name with the prefix <code>SINGLEA_</code> (or with another one specified in the <code>env_prefix</code> explicit parameter). For example, the value of the <code>client_id</code> parameter can be specified via <code>SINGLEA_CLIENT_ID</code> environment variable. This can be helpful, if you configure requests proxying to multiple client applications through a single nginx instance.</p> <p>You can mix both ways of specifying the client parameters. Explicit parameters have a higher priority.</p> <p>The SingleA client parameters are listed below. The required parameters are listed at the beginning (marked with <code>*</code>), which must be specified in any way. Parameter names will be shown according the names of explicit parameters in the client constructor (in a lowercase and without a prefix).</p> <ul> <li><code>base_url</code>* \u2014 scheme and domain (with a port, if necessary) of the SingleA server   (e.g. <code>https://sso.domain.org:1234</code>).</li> <li><code>client_id</code>* \u2014 the client identifier that was returned at registration.</li> <li><code>secret</code>* \u2014 the client secret that was returned at registration.</li> <li><code>client_base_url</code> \u2014 scheme and domain (with a port, if necessary) of the client application. By   default, the variables <code>ngx.var.scheme</code> and <code>ngx.var.http_host</code> are used, but there are cases when   you need to specify this parameter manually. For example, you can use the reverse proxy   Traefik, which handles request over https (port 443) and pass   them to the nginx instance, which operates over http (port 80). In this case the <code>ngx.var.scheme</code>   variable will be equal to <code>http</code> that is incorrect.</li> <li><code>signature_key</code> \u2014 the private key, which used for sign requests (see   the Request Signature feature description). If this parameter is   omitted, requests will not be signed.</li> <li><code>signature_md_algorithm</code> (default: <code>SHA256</code>) \u2014 the message digest algorithm (hash function) used   to sign the request.</li> <li><code>request_timeout</code> (default: <code>30</code>) \u2014 the timeout for internal requests between the SingleA client   and the server (user session validation and user token generation).</li> <li><code>ssl_not_verify</code> \u2014 if any non-empty value is specified, it prevents SSL certificate verification   for internal requests between the SingleA client and the server. This can be useful in the   development process or for testing purposes.</li> <li><code>realm</code> \u2014 the Realm value that should be used by the SingleA   server.</li> <li><code>ticket_cookie_name</code> (default: <code>tkt</code>) \u2014 the name of a cookie, which should contain the   user ticket.</li> <li><code>ticket_header</code> (default: <code>X-Ticket</code>) \u2014 the name of an HTTP header, which should contain the   ticket value in internal requests between the SingleA client and server.</li> <li><code>token_dict</code> (default: <code>tokens</code>) \u2014 the name of the shared dictionary where the received user token   will be cached by the SingleA client.</li> </ul> Shared dictionary for user tokens caching <p>The shared dictionary is created by the <code>lua_shared_dict</code> nginx directive, which was mentioned above in the Installation section. It creates the key-value in-memory storage shared between all nginx workers, which size is limited by the specified in the directive value. When the SingleA client receive the user token, it stores this token in the storage (cache) for the time specified in the <code>Cache-Control: max-age</code> HTTP header (if it exists in the response with the token, otherwise the token is not cached). Until the cache item will expire (or will be flushed, see <code>token_flush_header</code> parameter description below), the token value will be fetched from the cache, and not requested from the SingleA server.</p> <p>When the nginx daemon is restarted, the cache storage is cleared. See the <code>lua_shared_dict</code> directive description for more details.</p> <ul> <li><code>token_header</code> (default: <code>Authorization</code>) \u2014 the name of an HTTP header of an original request,   which should be written by the SingleA client and should contain the user token that received from   the SingleA server or from the cache (shared dictionary).</li> <li><code>token_prefix</code> (default: <code>Bearer</code>, with a space in the ending) \u2014 the prefix, which should be   added to the token header before the user token value.</li> <li><code>token_flush_header</code> (default: <code>X-Flush-Token</code>) \u2014 the name of an HTTP header, which used in 2   cases:<ul> <li>You can flush user token using the <code>flush_token()</code> client method after the request   processing. This method looks for the flush header in the response, which was generated by the   client application (see the second example below).</li> <li>You can enforce the client to remove cached token value in the <code>token()</code> client method with   subsequent receiving of the fresh user token and adding it to the original request.</li> </ul> </li> <li><code>client_id_query_parameter</code> (default: <code>client_id</code>) \u2014 the name of the GET parameter with the client   identifier value.</li> <li><code>secret_query_parameter</code> (default: <code>secret</code>) \u2014 the name of the GET parameter with the client   secret.</li> <li><code>realm_query_parameter</code> (default: <code>realm</code>) \u2014 the name of the GET parameter with the realm value.</li> <li><code>signature_query_parameter</code> (default: <code>sg</code>) \u2014 the name of the GET parameter with the request   signature.</li> <li><code>timestamp_query_parameter</code> (default: <code>ts</code>) \u2014 the name of the GET parameter with the timestamp   when the request was created.</li> <li><code>redirect_uri_query_parameter</code> (default: <code>redirect_uri</code>) \u2014 the name of the GET parameter with the   URI to which the user should be redirected after a successful operation on the SingleA server side   (used for user login and logout).</li> <li><code>login_path</code>, <code>logout_path</code>, <code>validate_path</code>, <code>token_path</code> (defaults: <code>/login</code>, <code>/logout</code>,   <code>/validate</code> and <code>/token</code>) \u2014 relative paths of the methods on the SingleA server side for user   login, logout, the user session validation, and user token generation.</li> </ul> <p>Parameters <code>*_query_param</code> and <code>*_path</code> make it possible to customize the GET parameters and the routes in case the default values cannot be used. On the server side there is an ability to change names of the GET parameters. The paths of the routes can be changed via standard way of the routes customization (using the <code>config/routes.yaml</code> and <code>config/routes/*.yaml</code> files).</p>"},{"location":"client/nginx/#usage","title":"Usage","text":"<p>The SingleA Lua client has the following methods.</p> <ul> <li><code>login()</code> \u2014 check that the ticket cookie exists and validate the user session (on the SingleA   server side). If there is no cookie or the user session is invalid, redirect the user to login on   the SingleA server and specify the current request URI as the <code>redirect_uri</code> parameter value.</li> <li><code>logout()</code> \u2014 if the request contains the ticket cookie, redirect the user to logout on the SingleA   server side with specifying the current request URI as the <code>redirect_uri</code> parameter value.</li> <li><code>validate()</code> \u2014 if the request contains the ticket cookie, validate the user session (on the   SingleA server side). Returns an HTTP error Unauthorized 401 if the session is invalid or the   request does not contain the ticket cookie.</li> <li><code>token(auth_required=true)</code> \u2014 send an HTTP request to the SingleA server to receive an   authenticated user token. The decision to check the user's session or not is up to the client   application developer (see the first example below, where the <code>login()</code> method   precedes the <code>token()</code> method). The <code>token()</code> method will return an HTTP error Unauthorized   401 if the user is not authorized. It is possible to call this method with optional boolean   argument <code>auth_required</code> set to <code>false</code>. In this case, if the user is not authorized, the error   will not be returned and the request will continue processing (without an HTTP header with the   user token, of course).</li> </ul> <p>All these methods, excepts <code>logout()</code>, return the client instance, which allows using of method chaining.</p>"},{"location":"client/nginx/#examples","title":"Examples","text":"<p>Below are few examples of using the SingleA Lua client.</p> <p>1. Login if necessary, request user token and add it into an original request</p> <p>Pay attention on explicit parameters specified for the <code>new</code> method (the client constructor).</p> <pre><code>server {\n  location ~ ^/any$ {\n    rewrite_by_lua_block {\n       require(\"singlea-client\").new {\n          client_id = \"hard_coded_client_id\",\n          request_timeout = 10,\n          token_header = \"Custom-Authorization\",\n       }\n          :login()\n          :token()\n    }\n    # ...\n  }\n}\n</code></pre> <p>2. Request user token if authenticated only and flush the token if required (via flush header)</p> <pre><code>server {\n  location ~ ^/any$ {\n    rewrite_by_lua_block {\n       require(\"singlea-client\").new()\n          :token(false)\n    }\n\n    # Some request processing, e.g. with FastCGI\n    # ...\n\n    header_filter_by_lua_block {\n       require(\"singlea-client\").new()\n          :flush_token()\n    }\n  }\n}\n</code></pre> <p>3. Validate user session only</p> <pre><code>server {\n  location ~ ^/any$ {\n    rewrite_by_lua_block {\n       require(\"singlea-client\").new()\n          :validate()\n    }\n    # ...\n  }\n}\n</code></pre> <p>Use <code>\"/n\"</code> as a newline when pass a signature key as an explicit constructor parameter or an environment variable.</p>"},{"location":"client/nginx/#self-payload-service","title":"Self Payload Service","text":"<p>If you are going to use the client application as an external service for the Payload Fetcher feature, do not forget to exclude such requests from processing by the client (because these requests do not contain user ticket cookie).</p> <p>In the following example assumed that the SingleA server sends Payload Fetcher requests to the <code>/_payload</code> path on the client application domain:</p> <pre><code>location ~ ^/any$ {\n  rewrite_by_lua_block {\n     if ngx.var.request_uri:sub(1, 9) == '/_payload' then\n        return\n     end\n\n     require(\"singlea-client\").new()\n        :login()\n        :token()\n  }\n  # ...\n</code></pre>"},{"location":"client/nginx/#cors-and-options-requests","title":"CORS and <code>OPTIONS</code> Requests","text":"<p>If you need to process <code>OPTIONS</code> requests, you can handle such requests directly in the Lua code:</p> <pre><code>location ~ ^/any$ {\n  rewrite_by_lua_block {\n     if ngx.var.request_method == 'OPTIONS' then\n        ngx.header['Access-Control-Allow-Origin'] = 'static.domain.org'\n        ngx.header['Access-Control-Allow-Methods'] = 'HEAD, GET, POST, PUT, PATCH, DELETE'\n        ngx.header['Access-Control-Allow-Headers'] = 'Content-Type, Accept, Cache-Control, X-Requested-With'\n        ngx.header['Content-Type'] = 'text/plain; charset=utf-8'\n        ngx.header['Content-Length'] = 0\n        ngx.exit(ngx.HTTP_NO_CONTENT)\n     end\n\n     require(\"singlea-client\").new()\n        :login()\n        :token()\n  }\n  # ...\n</code></pre>"},{"location":"features/about/","title":"About SingleA Features","text":"<p>One of the key features of the SingleA project is a modular approach for code organization. Modules in SingleA have a special name \u2014 Features. This is a reference to the feature oriented architecture. The SingleA Features based on the following principles.</p> <ul> <li>Each feature has a key (name) and a hash (implementation). The registration request data   must contain the name as a root key for the feature configuration, and the implementation as a \"#\"   item. The \"#\" item may be omitted if the feature has only one implementation (in this case the key   and hash must be equal).</li> </ul> <pre><code>{\n    \"some-feature-name\": {\n        \"#\": \"some-implementation\",\n        \"option\": \"value\",\n        # ...\n    }\n}\n</code></pre> <ul> <li> <p>Each client can enable only one feature (as a result of registration), but different clients can   enable different implementations of the same feature. For example, clients can   enable JSON Fetcher or JWT Fetcher as an implementation of   the Payload Fetcher feature.</p> </li> <li> <p>Each feature has a config that must have an interface, which must extend   the <code>SingleA\\Contracts\\FeatureConfig\\FeatureConfigInterface</code>. Also, for creating an instance of   the feature config from client registration data, it is necessary   the <code>SingleA\\Contracts\\FeatureConfig\\FeatureConfigFactoryInterface</code> to be implemented.</p> </li> </ul> <p>Using the config and config factory interfaces you can both customize behavior of existing features implementations, and create your own implementations.</p> <p>It is worth to be noted that the interfaces <code>SingleA\\Contracts\\FeatureConfig\\FeatureConfigInterface</code> and <code>SingleA\\Contracts\\FeatureConfig\\FeatureConfigFactoryInterface</code> are the part of the SingleA Contracts, which is another one concept underlying the SingleA project.</p> <p>The SingleA project includes implementations of the Tokenization and Payload Fetcher features (as separate bundles), and the Request Signature feature (as a part of the SingleA bundle).</p>"},{"location":"features/contracts/","title":"SingleA Contracts","text":"<p>Inspired by the Symfony Contracts component.</p> <p>The SingleA Contracts is a set of interfaces, which make it possible to separate the abstract service layer of the SingleA Features from the implementation. Thanks to the contracts the SingleA features are easily interchangeable and extendable (through an ability to customize them and create your own implementations).</p> <p>Currently, the SingleA Contracts include the following (there may be more in the future):</p> <ul> <li>FeatureConfig \u2014 basic interfaces for   a SingleA Feature implementation.</li> <li>Persistence \u2014 interfaces of services   that responsible for persisting of feature configs and metadata of clients.</li> <li>Marshaller \u2014 interfaces of services for   marshalling and encrypting of feature configs.</li> <li>Tokenization \u2014 interfaces of the   Tokenization feature, which makes able to generate user tokens.</li> <li>PayloadFetcher \u2014 interfaces of the   Payload Fetcher feature, which makes able to receive an additional payload   data for the user token (during the token generation).</li> </ul>"},{"location":"features/payload-fetcher/","title":"Payload Fetcher","text":"<p>In the description of the Tokenization feature was mentioned, that the tokenizer takes as an argument an array with user data, but it was not considered how this array is composed. The fact is that it is composed in 2 phases:</p> <ul> <li>first, it is composing of the user attributes according   the user claims, specified in the client tokenization feature config;</li> <li>then, it is merging with the data, received using the Payload Fetcher feature, which is   considered closer below.</li> </ul> <p>This feature makes it possible to send an HTTP request to an external service to receive additional user data, which should then be merged with the token payload. This request will contain a set of user data similar to the payload for the user token. The main idea of the feature is that the client application may need some data as a part of the token payload, which is based on the business logic that is unknown on the SingleA server side.</p> <p>The most popular example is a mapping of user attributes to the user roles on the client application side. Suppose that the user attributes contain the user groups from Active Directory (which may be used as an Identity Provider). You can create the web service, which will take a request with the user groups list and return the list of user roles in the client application, based on these groups. Using the Payload Fetcher, the SingleA server sends an HTTP request to your web service and will merge received data to the token payload. It is worth to be noted, that this HTTP request is made only on the token generation, and with help of the token TTL the SingleA server will prevent excessive load on your web service. This approach is an alternative for a mapping the user groups to the roles on each request on the client application side.</p> <p>The SingleA project have 2 implementations of the Payload Fetcher feature.</p> <ul> <li> <p>JSON Fetcher \u2014 send user data as a JSON to an external service   endpoint and expects to receive a JSON as a response, which must be merged with the token payload.   Use this implementation of Payload Fetcher in the secured network only, where it is impossible for   attackers to intercept the data during transmission over the network.</p> </li> <li> <p>JWT Fetcher \u2014 send user data as JWT payload. The JWT has a mandatory   signature and can be encrypted (optionally). It is recommended to use this implementation in any   case, when you are not absolutely sure about your network safety and data transmission between the   SingleA server and the external service can be intercepted. Read more about this in   the SingleA Security section.</p> </li> </ul>"},{"location":"features/signature/","title":"Request Signature","text":"<p>When processing requests, it is important to be sure that they were sent from the trusted source and were not forged during the network transmission. This is especially true for login and logout requests, which include the GET parameter that points to the URI where the user must be redirected after successful authentication or logout.</p> <p>An attack with valid requests, which do not depend on the request sent time, is also a danger. It leads to a reduced SingleA performance.</p> <p>The Request Signature feature do not provide complete solution to protect the SingleA server from DoS attacks.</p> <p>To solve this issues the SingleA bundle contains the Request Signature feature, which allows the user or client to pass in a request the following GET parameters:</p> <ul> <li>digital signature of remaining GET parameters of the request;</li> <li>timestamp of the beginning of the request.</li> </ul> <p>The SingleA server checks whether the request has not expired and whether the signature is valid (according remaining GET parameters; you can exclude some additional parameters from validation using the <code>singlea.signature.extra_exclude_query_parameters</code> parameter).</p> <p>When the client application register, it is possible to specify the <code>signature.skew</code> parameter, which should contain a number (positive or negative) of seconds that will be added to the <code>timestamp</code> value from the request before comparison with the server time. This is helpful when the client and the server work in different timezones. For example, if the server works in the UTC-4 timezone and the client in the UTC+2 timezone (difference is six hours), the client registration request can include the <code>signature.skew</code> parameter with <code>-21600</code> as a value (the server time minus the client time).</p> <p>It should be noted, that the server time for comparison is given at the moment when the request was come to the processing, not when it is actually being processed. This allows you not to worry about the duration of the user's interactive login.</p> <p>To use this feature you must use the <code>is_valid_signature()</code> security expression in an <code>allow_if</code> option of a <code>security.access_control</code> rule.</p> <p>SingleA does not use the Symfony Rate Limiter component, but you can do it. Easiest way to use the Rate Limiter with the SingleA controllers is to create an event subscriber for the event <code>Symfony\\Component\\HttpKernel\\Event\\ControllerEvent</code> and add Rate Limiter usage for the necessary controllers.</p>"},{"location":"features/tokenization/","title":"Tokenization","text":"<p>In most cases, it is not enough to just authenticate the user. It is necessary to obtain the user data: name, email(s), roles, etc. To solve this issue the SingleA project have the Tokenization feature, which makes it possible to generate user tokens.</p> <p>A user token is a unique string that provides access to user data for a client application. Perhaps, the most popular example of a token can be considered JWT (RFC 7519: JSON Web Token). In this format user data encoded directly in the token content. The SingleA project includes an implementation of the Tokenization feature based on the JWT format. You can read more about it in the JWT bundle section.</p> <p>JWT is not the only way to transmit user data to the client application. You can create your own implementation of this feature. For example, it can store user data in some storage, shared by the SingleA server and the client application, and use as a token value the key that is used to fetch stored data. Whatever the token generation logic is, you have to implement <code>SingleA\\Contracts\\Tokenization\\TokenizerInterface</code> and particularly the <code>TokenizerInterface::tokenize</code> method, which takes as arguments the user identifier, payload (an array with user data) and client feature config (which contains at least the token TTL and the names of user attributes for the token). As a result, <code>tokenize</code> should return a string that will be used as a user token.</p> <p>Regardless of the tokenizer implementation, a response with the token will contain an HTTP header <code>Cache-Control: max-age</code> with a value according the token lifetime from the client feature config (if it was specified at registration). This makes it possible to cache the token and avoid excessive load on the SingleA server.</p>"},{"location":"features/tokenization/#token-ttl","title":"Token TTL","text":"<p>Specify as a token lifetime a sufficiently small value at the client registration according to business logic of your application. The default value is 10 minutes.</p> <p>SingleA provide the <code>user:logout &lt;identifier&gt;</code> command that allows you to log the user out forcibly, so use the minimal possible value as a token TTL is not always justified. But if user data can be changed between token generation requests (not only on successful authentication; see <code>SingleA\\Bundles\\Singlea\\Event\\UserAttributesEvent</code> description in the SingleA bundle section), it makes sense to specify a small value, otherwise the client application will work with outdated data for a long time.</p>"}]}